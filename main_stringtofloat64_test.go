// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=stringToFloat64_d38659cd50
ROOST_METHOD_SIG_HASH=stringToFloat64_44e80853e6

FUNCTION_DEF=func stringToFloat64(str string) float64 
Scenario 1: Valid Conversion of String to Float64

Details:
  Description: This test checks if the function correctly converts a valid string representation of a floating-point number to a float64.
Execution:
  Arrange: Prepare a string containing a valid floating-point number.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test is important as it verifies the core functionality of the function under normal conditions.

Scenario 2: Conversion of Positive Integer String to Float64

Details:
  Description: This test verifies that the function correctly converts a string containing a positive integer to a float64.
Execution:
  Arrange: Prepare a string containing a positive integer.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test ensures that the function handles integer inputs correctly.

Scenario 3: Conversion of Negative Integer String to Float64

Details:
  Description: This test checks if the function correctly converts a string containing a negative integer to a float64.
Execution:
  Arrange: Prepare a string containing a negative integer.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test covers the handling of negative integer inputs.

Scenario 4: Conversion of Zero String to Float64

Details:
  Description: This test verifies that the function correctly converts a string containing zero to a float64.
Execution:
  Arrange: Prepare a string containing zero.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value is zero.
Validation:
  The choice of assertion is to check for exact equality between the returned value and zero. This test ensures that the function handles the zero value case correctly.

Scenario 5: Conversion of Floating-Point with Decimal String to Float64

Details:
  Description: This test checks if the function correctly converts a string containing a floating-point number with a decimal part to a float64.
Execution:
  Arrange: Prepare a string containing a floating-point number with a decimal part.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test ensures that the function handles decimal values correctly.

Scenario 6: Conversion of Scientific Notation String to Float64

Details:
  Description: This test verifies that the function correctly converts a string containing a number in scientific notation to a float64.
Execution:
  Arrange: Prepare a string containing a number in scientific notation.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test ensures that the function handles scientific notation inputs correctly.

Scenario 7: Invalid String Conversion Handling

Details:
  Description: This test checks if the function handles an invalid string input gracefully by exiting the program with a specific error code.
Execution:
  Arrange: Prepare a string containing an invalid representation of a number.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the program exits with error code 2 and an error message is printed.
Validation:
  The choice of assertion is to check for the program exit with a specific error code. This test is important as it ensures that the function handles invalid inputs robustly.

Scenario 8: Empty String Conversion Handling

Details:
  Description: This test verifies that the function handles an empty string input gracefully by exiting the program with a specific error code.
Execution:
  Arrange: Prepare an empty string.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the program exits with error code 2 and an error message is printed.
Validation:
  The choice of assertion is to check for the program exit with a specific error code. This test ensures that the function handles empty string inputs correctly.

Scenario 9: String with Whitespace Conversion Handling

Details:
  Description: This test checks if the function handles a string with leading or trailing whitespace gracefully by exiting the program with a specific error code.
Execution:
  Arrange: Prepare a string containing a valid floating-point number with leading or trailing whitespace.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the program exits with error code 2 and an error message is printed.
Validation:
  The choice of assertion is to check for the program exit with a specific error code. This test ensures that the function handles strings with whitespace correctly.

Scenario 10: String with Non-Numeric Characters Conversion Handling

Details:
  Description: This test verifies that the function handles a string containing non-numeric characters gracefully by exiting the program with a specific error code.
Execution:
  Arrange: Prepare a string containing a mix of numeric and non-numeric characters.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the program exits with error code 2 and an error message is printed.
Validation:
  The choice of assertion is to check for the program exit with a specific error code. This test ensures that the function handles strings with non-numeric characters correctly.

Scenario 11: Very Large Number String to Float64

Details:
  Description: This test checks if the function correctly converts a string containing a very large number to a float64.
Execution:
  Arrange: Prepare a string containing a very large number.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test ensures that the function handles very large numbers correctly.

Scenario 12: Very Small Number String to Float64

Details:
  Description: This test verifies that the function correctly converts a string containing a very small number to a float64.
Execution:
  Arrange: Prepare a string containing a very small number.
  Act: Invoke the stringToFloat64 function with the prepared string.
  Assert: Verify that the returned float64 value matches the expected value.
Validation:
  The choice of assertion is to check for exact equality between the returned value and the expected value. This test ensures that the function handles very small numbers correctly.

*/

// ********RoostGPT********


package calc

import (
	"fmt"
	"os"
	"runtime/debug"
	"strconv"
	"testing"
	"github.com/SHAKULMITTAL22/golang_calculator/calc"
)





type testCase struct {
	name     string
	input    string
	expected float64
}

func TestStringToFloat64(t *testing.T) {

	tests := []testCase{
		{name: "Valid Conversion of String to Float64", input: "3.14", expected: 3.14},
		{name: "Conversion of Positive Integer String to Float64", input: "123", expected: 123.0},
		{name: "Conversion of Negative Integer String to Float64", input: "-123", expected: -123.0},
		{name: "Conversion of Zero String to Float64", input: "0", expected: 0.0},
		{name: "Conversion of Floating-Point with Decimal String to Float64", input: "0.0001", expected: 0.0001},
		{name: "Conversion of Scientific Notation String to Float64", input: "1.23e4", expected: 12300.0},
		{name: "Invalid String Conversion Handling", input: "invalid", expected: 0.0},
		{name: "Empty String Conversion Handling", input: "", expected: 0.0},
		{name: "String with Whitespace Conversion Handling", input: " 3.14 ", expected: 0.0},
		{name: "String with Non-Numeric Characters Conversion Handling", input: "3.14a", expected: 0.0},
		{name: "Very Large Number String to Float64", input: "1.23456789e10", expected: 1.23456789e10},
		{name: "Very Small Number String to Float64", input: "1.23456789e-10", expected: 1.23456789e-10},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					t.Fail()
				}
			}()

			oldStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			result := stringToFloat64(tt.input)

			w.Close()
			os.Stdout = oldStdout

			var output string
			fmt.Fscanf(r, "%s", &output)

			if tt.name == "Invalid String Conversion Handling" || tt.name == "Empty String Conversion Handling" || tt.name == "String with Whitespace Conversion Handling" || tt.name == "String with Non-Numeric Characters Conversion Handling" {
				if output != "strconv.ParseFloat: parsing \"invalid\": invalid syntax" && tt.input == "invalid" {
					t.Errorf("Expected error message for invalid input, got none")
				} else if output != "strconv.ParseFloat: parsing \"\": invalid syntax" && tt.input == "" {
					t.Errorf("Expected error message for empty input, got none")
				} else if output != "strconv.ParseFloat: parsing \" 3.14 \": invalid syntax" && tt.input == " 3.14 " {
					t.Errorf("Expected error message for whitespace input, got none")
				} else if output != "strconv.ParseFloat: parsing \"3.14a\": invalid syntax" && tt.input == "3.14a" {
					t.Errorf("Expected error message for non-numeric input, got none")
				} else {
					t.Logf("Test passed: %s", tt.name)
				}
			} else {
				if result != tt.expected {
					t.Errorf("Expected %f, but got %f", tt.expected, result)
				} else {
					t.Logf("Test passed: %s", tt.name)
				}
			}
		})
	}
}