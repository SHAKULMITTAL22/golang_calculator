// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=SquareRoot_17095d9165
ROOST_METHOD_SIG_HASH=SquareRoot_232943a56a

FUNCTION_DEF=func SquareRoot(num float64) float64 // Square root (with error handling)

```go
Scenario 1: Positive Number Input

Details:
  Description: This test checks the functionality of the SquareRoot function with a positive number as input. It verifies that the function correctly computes the square root of a positive number.
Execution:
  Arrange: Define a positive number, e.g., 16.0.
  Act: Call the SquareRoot function with the positive number.
  Assert: Verify that the returned value is equal to the expected square root (4.0).
Validation:
  The choice of assertion is to check the correctness of the mathematical operation. The importance of this test is to ensure that the function correctly handles typical use cases.

Scenario 2: Zero Input

Details:
  Description: This test checks the functionality of the SquareRoot function with zero as input. It verifies that the function correctly returns zero.
Execution:
  Arrange: Define zero as the input.
  Act: Call the SquareRoot function with zero.
  Assert: Verify that the returned value is equal to zero.
Validation:
  The choice of assertion is to confirm that the function behaves correctly for the boundary case of zero. The importance of this test is to ensure that the function handles edge cases appropriately.

Scenario 3: Negative Number Input

Details:
  Description: This test checks the error handling of the SquareRoot function with a negative number as input. It verifies that the function panics with the appropriate error message.
Execution:
  Arrange: Define a negative number, e.g., -4.0.
  Act: Call the SquareRoot function with the negative number.
  Assert: Verify that the function panics and the panic message is "square root of a negative number is not defined".
Validation:
  The choice of assertion is to check that the function correctly identifies and handles invalid input. The importance of this test is to ensure that the function robustly handles erroneous input scenarios.

Scenario 4: Large Number Input

Details:
  Description: This test checks the functionality of the SquareRoot function with a large number as input. It verifies that the function correctly computes the square root of a large number.
Execution:
  Arrange: Define a large number, e.g., 1.0e12.
  Act: Call the SquareRoot function with the large number.
  Assert: Verify that the returned value is equal to the expected square root (1.0e6).
Validation:
  The choice of assertion is to check the correctness of the mathematical operation for large numbers. The importance of this test is to ensure that the function can handle large input values without precision issues.

Scenario 5: Small Number Input

Details:
  Description: This test checks the functionality of the SquareRoot function with a small number as input. It verifies that the function correctly computes the square root of a small number.
Execution:
  Arrange: Define a small number, e.g., 1.0e-12.
  Act: Call the SquareRoot function with the small number.
  Assert: Verify that the returned value is equal to the expected square root (1.0e-6).
Validation:
  The choice of assertion is to check the correctness of the mathematical operation for small numbers. The importance of this test is to ensure that the function can handle small input values without precision issues.

Scenario 6: Fractional Number Input

Details:
  Description: This test checks the functionality of the SquareRoot function with a fractional number as input. It verifies that the function correctly computes the square root of a fractional number.
Execution:
  Arrange: Define a fractional number, e.g., 0.25.
  Act: Call the SquareRoot function with the fractional number.
  Assert: Verify that the returned value is equal to the expected square root (0.5).
Validation:
  The choice of assertion is to check the correctness of the mathematical operation for fractional numbers. The importance of this test is to ensure that the function can handle fractional input values appropriately.
```
*/

// ********RoostGPT********

package calc

import (
	"runtime/debug"
	"testing"
)

func TestSquareRoot(t *testing.T) {

	type testCase struct {
		name        string
		input       float64
		expected    float64
		shouldPanic bool
	}

	testCases := []testCase{
		{"Positive Number Input", 16.0, 4.0, false},
		{"Zero Input", 0.0, 0.0, false},
		{"Negative Number Input", -4.0, 0.0, true},
		{"Large Number Input", 1.0e12, 1.0e6, false},
		{"Small Number Input", 1.0e-12, 1.0e-6, false},
		{"Fractional Number Input", 0.25, 0.5, false},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					if !tc.shouldPanic {
						t.Fail()
					}
				}
			}()

			result := SquareRoot(tc.input)

			if !tc.shouldPanic && result != tc.expected {
				t.Logf("Expected %f but got %f", tc.expected, result)
				t.Fail()
			} else if tc.shouldPanic && result != tc.expected {
				t.Logf("Expected panic but got %f", result)
				t.Fail()
			} else {
				t.Logf("Test passed successfully for input %f", tc.input)
			}
		})
	}
}
