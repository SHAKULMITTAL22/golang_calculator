// ********RoostGPT********
/*
Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=SquareRoot_17095d9165
ROOST_METHOD_SIG_HASH=SquareRoot_232943a56a

FUNCTION_DEF=func SquareRoot(num float64) float64 // Square root (with error handling)

Scenario 1: Testing a positive number's square root calculation
Details:
    Description: The test is intended to validate the correct square root calculation for a positive number.
  Execution:
    Arrange: A positive floating-point number, 16.0 for instance.
    Act: Invoking the SquareRoot function with 16.0 as a parameter.
    Assert: Verify the calculated square root is equal to 4.0.
  Validation:
    The Go tsting facilities will check that the result returned from SquareRoot(16.0) is equal to 4.0. This test ensures that the SquareRoot function accurately calculates the square root of a positive number.

Scenario 2: Testing a square root calculation of zero
Details:
    Description: This test examines the SquareRoot function's handling of zero, which should return 0.
  Execution:
    Arrange: The number zero.
    Act: Call the SquareRoot function with 0 as a parameter.
    Assert: Check if the calculated square root is also 0.
  Validation:
    The Go testing facilities will check whether SquareRoot(0) returns 0. This condition must be correctly handled since the square root of zero is logically zero.

Scenario 3: Testing a square root calculation of a negative number
Details:
    Description: To ensure the function properly handles invalid input (negative numbers), this test assigns -1 as a parameter, expecting the function to raise an exception.
  Execution:
    Arrange: A negative number, e.g., -1.
    Act: Call the SquareRoot function with -1 as a parameter.
    Assert: Check if an exception is raised.
  Validation:
    The Go tests will validate that an exception is thrown when SquareRoot(-1) is called. The inability to calculate the square root of a negative number is a mathematical axiom, thus the program should properly manage this situation.

Scenario 4: Testing a square root calculation of a decimal number
Details:
    Description: Tests the function's capacity to handle decimal numbers, expecting it to correctly calculate the square root.
  Execution:
    Arrange: A decimal number, such as 25.6.
    Act: Call the operation SquareRoot with 25.6 as a parameter.
    Assert: Verify the return is approximately 5.04975246918.
  Validation:
    The Go testing facilities will check the returned value with the expected (apprixomate) square root. It's crucial to test the ability of the function to work with floating points for both input and output as these cases are common in real applications.
*/

// ********RoostGPT********

package calc

import (
	"math"
	"testing"
)

type testCase struct {
	number          float64
	expectedResult  float64
	expectingPanic  bool
	testDescription string
}

func TestSquareRoot(t *testing.T) {

	tt := []testCase{
		{16.0, 4.0, false, "Testing a positive number's square root calculation"},
		{0, 0, false, "Testing a square root calculation of zero"},
		{-1, 0, true, "Testing a square root calculation of a negative number"},
		{25.6, 5.04975246918, false, "Testing a square root calculation of a decimal number"},
	}

	for _, tc := range tt {
		t.Run(tc.testDescription, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if tc.expectingPanic {
						t.Logf("Panic encountered as expected: %v", r)
					} else {
						t.Errorf("Panic encountered while not expected: %v", r)
					}
				} else if tc.expectingPanic {
					t.Errorf("Expected a panic but didn't encounter one")
				}
			}()

			result := SquareRoot(tc.number)

			tolerance := 0.000000001
			if math.Abs(result-tc.expectedResult) > tolerance {
				t.Errorf("SquareRoot(%v): %v, expected %v within tolerance", tc.number, result, tc.expectedResult)
			} else {
				t.Log("Success!")
			}
		})
	}
}
