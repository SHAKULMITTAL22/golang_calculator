// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=SquareRoot_e78e2534d2
ROOST_METHOD_SIG_HASH=SquareRoot_59e4e007cb

FUNCTION_DEF=// Square root (with error handling)
func SquareRoot(num float64) float64 
Scenario 1: Normal Operation - Positive Integer

Details:
  Description: This test checks the function's behavior with a positive integer input to ensure it returns the correct square root.
Execution:
  Arrange: None.
  Act: Call SquareRoot with a positive integer, e.g., 16.
  Assert: Verify that the returned value is 4.
Validation:
  The choice of assertion is straightforward as we expect a known mathematical result. This test is crucial for verifying the correctness of the function for typical use cases.

Scenario 2: Normal Operation - Positive Float

Details:
  Description: This test checks the function's behavior with a positive floating-point number input to ensure it returns the correct square root.
Execution:
  Arrange: None.
  Act: Call SquareRoot with a positive float, e.g., 2.25.
  Assert: Verify that the returned value is 1.5.
Validation:
  The choice of assertion is straightforward as we expect a known mathematical result. This test is crucial for verifying the correctness of the function for typical use cases involving floats.

Scenario 3: Edge Case - Zero

Details:
  Description: This test checks the function's behavior with zero input to ensure it returns zero.
Execution:
  Arrange: None.
  Act: Call SquareRoot with 0.
  Assert: Verify that the returned value is 0.
Validation:
  The choice of assertion is straightforward as the square root of zero is zero. This test is important to ensure the function handles the edge case of zero correctly.

Scenario 4: Error Handling - Negative Integer

Details:
  Description: This test checks the function's behavior with a negative integer input to ensure it panics with the correct error message.
Execution:
  Arrange: None.
  Act: Call SquareRoot with a negative integer, e.g., -4.
  Assert: Verify that the function panics with the message "square root of a negative number is not defined".
Validation:
  This test is crucial for verifying that the function correctly handles invalid input by panicking with the appropriate error message. This behavior is critical for maintaining the integrity of the application.

Scenario 5: Error Handling - Negative Float

Details:
  Description: This test checks the function's behavior with a negative floating-point number input to ensure it panics with the correct error message.
Execution:
  Arrange: None.
  Act: Call SquareRoot with a negative float, e.g., -2.25.
  Assert: Verify that the function panics with the message "square root of a negative number is not defined".
Validation:
  This test is crucial for verifying that the function correctly handles invalid input by panicking with the appropriate error message. This behavior is critical for maintaining the integrity of the application.

Scenario 6: Large Positive Number

Details:
  Description: This test checks the function's behavior with a large positive number input to ensure it returns the correct square root.
Execution:
  Arrange: None.
  Act: Call SquareRoot with a large positive number, e.g., 1e10.
  Assert: Verify that the returned value is 1e5.
Validation:
  The choice of assertion is straightforward as we expect a known mathematical result. This test is important for verifying the correctness of the function with large inputs, ensuring there are no overflow or precision issues.

Scenario 7: Small Positive Number

Details:
  Description: This test checks the function's behavior with a small positive number input to ensure it returns the correct square root.
Execution:
  Arrange: None.
  Act: Call SquareRoot with a small positive number, e.g., 1e-10.
  Assert: Verify that the returned value is 1e-5.
Validation:
  The choice of assertion is straightforward as we expect a known mathematical result. This test is important for verifying the correctness of the function with small inputs, ensuring there are no underflow or precision issues.

*/

// ********RoostGPT********


package calc

import (
	"math"
	"runtime/debug"
	"testing"
)





type testCase struct {
		name     string
		input    float64
		expected float64
	}

func TestSquareRoot(t *testing.T) {
	tests := []testCase{

		{name: "Positive Integer", input: 16, expected: 4},

		{name: "Positive Float", input: 2.25, expected: 1.5},

		{name: "Zero", input: 0, expected: 0},

		{name: "Negative Integer", input: -4, expected: 0},

		{name: "Negative Float", input: -2.25, expected: 0},

		{name: "Large Positive Number", input: 1e10, expected: 1e5},

		{name: "Small Positive Number", input: 1e-10, expected: 1e-5},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if tc.input >= 0 {
						t.Logf("Panic encountered but not expected. %v\n%s", r, string(debug.Stack()))
						t.Fail()
					} else {
						t.Logf("Panic encountered as expected: %v", r)
					}
				}
			}()

			result := SquareRoot(tc.input)

			if tc.input < 0 {
				t.Errorf("Expected panic but none occurred for input %v", tc.input)
			} else {
				if math.Abs(result-tc.expected) > 1e-9 {
					t.Errorf("Expected %v but got %v for input %v", tc.expected, result, tc.input)
				} else {
					t.Logf("Test passed successfully for input %v", tc.input)
				}
			}
		})
	}
}