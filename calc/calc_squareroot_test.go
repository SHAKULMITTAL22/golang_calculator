// ********RoostGPT********
/*
Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=SquareRoot_17095d9165
ROOST_METHOD_SIG_HASH=SquareRoot_232943a56a

FUNCTION_DEF=func SquareRoot(num float64) float64 // Square root (with error handling)

Scenario 1: Testing square root of a positive number

Details:
    Description: This test checks if the function accurately calculates the square root of a positive number.
Execution:
    Arrange: No specific arrangement necessary as it just requires a numeric input.
    Act: Invoke the SquareRoot function with a positive number, like 16.
    Assert: Check that the function accurately returns the square root of 16, which is 4.
Validation:
    This assertion checks if the math.Sqrt library function used in the SquareRoot function works accurately. This is the basic functionality of this function hence important to test.

Scenario 2: Testing square root of zero

Details:
    Description: This test checks if the function accurately calculates the square root of zero which should be zero.
Execution:
    Arrange: No specific arrangement necessary as it just requires a numeric input.
    Act: Invoke the SquareRoot function with 0.
    Assert: Check that the function accurately returns 0.
Validation:
    This assertion checks if the math.Sqrt library function used in the SquareRoot function works accurately for zero. This is also a basic functionality of this function and helps in testing how the function handles edge cases.

Scenario 3: Testing square root of a negative number

Details:
    Description: This test checks if the function handles the error correctly when attempting to calculate the square root of a negative number.
Execution:
    Arrange: No specific arrangement necessary as it just requires a numeric input.
    Act: Invoke the SquareRoot function with a negative number, like -4.
    Assert: Check that the function panics with the appropriate error message.
Validation:
    This assertion checks if our error handling is accurateâ€”that is, we're panicking with the correct error message. This is important to test, because calculating the square root of a negative number is a mathematical impossibility, and these negative numbers as input should therefore be considered invalid test cases.
*/

// ********RoostGPT********

package calc

import (
	"runtime/debug"
	"testing"
)

func TestSquareRoot(t *testing.T) {
	type args struct {
		num float64
	}

	tests := []struct {
		name      string
		args      args
		want      float64
		wantPanic bool
	}{
		{
			name: "Scenario 1: Testing square root of a positive number",
			args: args{
				num: 16,
			},
			want:      4,
			wantPanic: false,
		},
		{
			name: "Scenario 2: Testing square root of zero",
			args: args{
				num: 0,
			},
			want:      0,
			wantPanic: false,
		},
		{
			name: "Scenario 3: Testing square root of a negative number",
			args: args{
				num: -4,
			},
			want:      0,
			wantPanic: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					t.Fail()
				}
			}()

			if got := SquareRoot(tt.args.num); got != tt.want {
				t.Errorf("The SquareRoot function returns incorrect result. Want = %v, got = %v\n", tt.want, got)
			}
			if !tt.wantPanic {
				return
			}
			gotPanic := false
			func() {
				defer func() {
					if r := recover(); r != nil {
						gotPanic = true
					}
				}()
				SquareRoot(tt.args.num)
			}()
			if gotPanic != tt.wantPanic {
				t.Errorf("Expected panic but did not get one.")
			}
		})
	}
}
