// ********RoostGPT********
/*
Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=SquareRoot_17095d9165
ROOST_METHOD_SIG_HASH=SquareRoot_232943a56a

FUNCTION_DEF=func SquareRoot(num float64) float64 // Square root (with error handling)

Scenario 1: Testing with a positive number
Details:
  Description: This test is meant to check if the function correctly calculates the square root of a positive number.
Execution:
  Arrange: No need for additional setup as we are directly passing a constant positive value.
  Act: Call the SquareRoot function with a positive number for example 9.
  Assert: Verify that the returned value matches the actual square root of the number. For 9, it should be 3.
Validation:
  The chosen assertion type is Equal, as we expected an exact value as a result. This test is crucial to ensure that the function correctly calculates the square root.

Scenario 2: Testing with a negative number
Details:
  Description: This case is to check if the function correctly handles the scenarios where the square root of a negative number was asked for.
Execution:
  Arrange: No need for additional setup as we are directly passing a constant negative value.
  Act: Call the SquareRoot function with a negative number like -9, This should cause the function to panic.
  Assert: Use Go's recover function in a defer block to catch the panic, and check that the panic message matches the expected message.
Validation:
 This test is crucial to validate that the application handles error scenarios correctly, as attempting to take the square root of a negative number is mathematically undefined.

Scenario 3: Testing with zero
Details:
  Description: This test is meant to check if the function correctly calculates the square root of zero, which should also be zero.
Execution:
  Arrange: No need for additional setup as we are directly passing a constant value.
  Act: Call the SquareRoot function with 0 as parameter.
  Assert: Verify that the returned value is also 0.
Validation:
  The chosen assertion type is Equal, as we expected an exact value as a result. This test is crucial as zero is an edge case where the output is the same as the input.

Scenario 4: Testing with a very large number
Details:
  Description: This test is to verify that our function can correctly calculate the square root for very large numbers.
Execution:
  Arrange: Pass a large number to the function.
  Act: Call the function with the large number and collect the return value.
  Assert: Verify that the return value is correct by squaring the result and comparing it to the original large number.
Validation:
  This test is to ensure our function can handle large input values and still produce the correct output.
*/

// ********RoostGPT********

package calc

import (
	"math"
	"testing"
)

func TestSquareRoot(t *testing.T) {

	tests := []struct {
		name        string
		input       float64
		want        float64
		shouldPanic bool
	}{
		{
			name:        "Testing with a positive number",
			input:       9,
			want:        3,
			shouldPanic: false,
		},
		{
			name:        "Testing with a negative number",
			input:       -9,
			want:        0,
			shouldPanic: true,
		},
		{
			name:        "Testing with zero",
			input:       0,
			want:        0,
			shouldPanic: false,
		},
		{
			name:        "Testing with a very large number",
			input:       1e10,
			want:        math.Sqrt(1e10),
			shouldPanic: false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Logf("Running Test - %s", tc.name)

			defer func() {
				if r := recover(); r != nil {
					if tc.shouldPanic {
						t.Log("Panic correctly occurred")
					} else {
						t.Logf("Panic encountered so failing test. %v - Test Failed", r)
						t.Fail()
					}
				} else {
					if tc.shouldPanic {
						t.Logf("Panic did not occur but was expected - Test Failed")
						t.Fail()
					}
				}
			}()

			got := SquareRoot(tc.input)
			if got != tc.want && !tc.shouldPanic {
				t.Errorf("SquareRoot(%v) = %v; want %v - Test Failed", tc.input, got, tc.want)
			} else {
				t.Logf("All assertions passed successfully - Test Passed")
			}
		})
	}
}
