// ********RoostGPT********
/*
Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=SinCosTan_c6521a7850
ROOST_METHOD_SIG_HASH=SinCosTan_6ec04d6e93

FUNCTION_DEF=func SinCosTan(angle float64) (sin, cos, tan float64)
```
Scenario 1: Test SinCosTan with zero angle.

Details:
  Description: The test is meant to check the functionality of the SinCosTan function when the input angle is zero.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the SinCosTan function with the angle parameter as 0.
  Assert: Check that the returned sin, cos, tan values are 0, 1, 0 respectively.
Validation:
  The assertion choice is based on the mathematical laws where sin(0)=0, cos(0)=1, tan(0)=0. This test ensures that the function handles the edge case where the angle is zero and returns the correct values.

Scenario 2: Test SinCosTan with 90 degree angle or pi/2 radian.

Details:
  Description: The test aims to verify the results of the SinCosTan function when the input angle is 90 degrees or pi/2 in radian.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the function SinCosTan with the angle parameter as math.Pi/2.
  Assert: Check that the returned sin, cos, tan values are close to 1, 0, and Infinity respectively.
Validation:
  The assertion choice is based on the mathematical laws where sin(90°)=1, cos(90°)=0, tan(90°)=Infinity. This test ensures that the function handles the edge case where angle is 90° and returns the correct values.

Scenario 3: Test SinCosTan with negative angle.

Details:
  Description: This test aims to verify the results of the SinCosTan function when the input angle is a negative number.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the SinCosTan function with a negative angle.
  Assert: Negate the returned sin and tan values and check that they match the values returned for the corresponding positive angle. The cos value should match cos of positive angle.
Validation:
  The assertion choice is made on the basis that the sin and tan of a negative angle are themselves negative. This test is important to verify that the SinCosTan function handles negative input angle and calculates the correct sin, cos, and tan values accordingly.

Scenario 4: Test SinCosTan with angle larger than 360°.

Details:
  Description: This test aims to verify that the SinCosTan function handles angles greater than 360°, by using circular property of trigonometric functions.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the SinCosTan function with an angle larger than 360°.
  Assert: Check that the returned sin, cos, tan values match the values returned for the angle mod 360.
Validation:
  The assertion choice is made on the principle that trigonometric functions are periodic with a period of 360°. This test ensures that the function correctly calculates the sin, cos, and tan values for angles larger than 360°.
```
*/

// ********RoostGPT********

package calc

import (
	"fmt"
	"math"
	"testing"
)

func TestSinCosTan(t *testing.T) {

	tests := []struct {
		name  string
		angle float64
		sin   float64
		cos   float64
		tan   float64
	}{
		{"Zero Angle", 0, 0, 1, 0},
		{"Pi/2 Angle", math.Pi / 2, 1, 0, math.Inf(1)},
		{"Negative Angle", -math.Pi / 2, -1, 0, math.Inf(-1)},
		{"Angle greater than 360", math.Pi * (360 + 30) / 180, math.Sin(math.Pi * 30 / 180), math.Cos(math.Pi * 30 / 180), math.Tan(math.Pi * 30 / 180)},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v", r)
					t.Fail()
				}
			}()

			gotSin, gotCos, gotTan := SinCosTan(tt.angle)
			if !isCloseEnough(gotSin, tt.sin) || !isCloseEnough(gotCos, tt.cos) || !isCloseEnough(gotTan, tt.tan) {
				t.Errorf("SinCosTan(%v) = %v, %v, %v; want %v, %v, %v", tt.angle, gotSin, gotCos, gotTan, tt.sin, tt.cos, tt.tan)
			}
		})
	}
}
func isCloseEnough(a, b float64) bool {
	tolerance := 0.00000001
	if diff := math.Abs(a - b); diff > tolerance {
		fmt.Println("diff:", diff)
		return false
	}
	return true
}
