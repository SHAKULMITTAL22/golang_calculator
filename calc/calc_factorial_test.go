// ********RoostGPT********
/*
Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=Factorial_89543dc467
ROOST_METHOD_SIG_HASH=Factorial_9b038c83eb

FUNCTION_DEF=func Factorial(n int) int
Scenario 1: Testing with Positive Integer Input

Details:
    Description: This test is meant to check if the Factorial function works correctly for positive integers. Given a positive integer 'n', the function should calculate the factorial.
  Execution:
    Arrange: A positive integer value for 'n' is needed.
    Act: Invoke the Factorial function with 'n'.
    Assert: The result returned by the Factorial function is compared with the expected factorial value of 'n'.
  Validation:
    The assertion checks if the factorial is correctly calculated for positive integers. The expected result is based on the fundamental definition of factorial in mathematics.


Scenario 2: Testing with Zero as Input

Details:
    Description: This test is aimed at checking if the Factorial function works accurately when 'n' equals to zero. According to mathematics, the factorial of zero is 1.
  Execution:
    Arrange: 'n' is set as 0.
    Act: The Factorial function is called with 'n'
    Assert: The result returned by the Factorial function is checked to be 1.
  Validation:
    It validates the condition n == 0 in the Factorial function. Standard mathematical rule states the factorial of 0 is 1 which is the expected result.

Scenario 3: Testing with Negative Integer Input

Details:
    Description: The goal of this test scenario is to check if the Factorial function throws error when a negative integer is passed. The function should panic for negative inputs as factorial of a negative number is undefined.
  Execution:
    Arrange: A negative integer value for 'n' is needed.
    Act: Invoke the Factorial function with 'n'.
    Assert: An error recovery mechanism asserts that a panic is triggered as expected.
  Validation:
    We check if the function throws the expected error. This validates the function's first line in the logic i.e., if n < 0, panic().


Scenario 4: Testing with Maximum Integer Input

Details:
    Description: This test aims to check the behavior of the Factorial function with very large numbers. This is done to verify if the function handles edge cases of maximum integer values without any overflow errors.
  Execution:
    Arrange: Select the maximum possible integer value defined by Go as 'n'.
    Act: Call the Factorial function with 'n'.
    Assert: An error recovery mechanism is required, as for large 'n' it is likely to cause integer overflow and result in a panic/error.
  Validation:
    The test ensures that the application handles integer overflows properly. An integral part of robustness for any application, particularly one involving factorial calculation, as they can reach large numbers very quickly.
*/

// ********RoostGPT********

package calc

import (
	"math"
	"runtime/debug"
	"testing"

	calc "github.com/SHAKULMITTAL22/golang_calculator/calc"
)

func TestFactorial(t *testing.T) {

	tests := []struct {
		description string
		input       int
		expected    int
		shouldPanic bool
	}{
		{
			description: "Testing with Positive Integer Input",
			input:       7,
			expected:    5040,
			shouldPanic: false,
		},
		{
			description: "Testing with Zero as Input",
			input:       0,
			expected:    1,
			shouldPanic: false,
		},
		{
			description: "Testing with Negative Integer Input",
			input:       -5,
			expected:    0,
			shouldPanic: true,
		},
		{
			description: "Testing with Maximum Integer Input",
			input:       math.MaxInt64,
			expected:    0,
			shouldPanic: true,
		},
	}

	for _, test := range tests {
		test := test

		t.Run(test.description, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if test.shouldPanic {
						t.Logf("Expected and Encountered Panic: %v\n%s", r, string(debug.Stack()))
					} else {
						t.Errorf("Did not Expect Panic but got Panic: %v\n%s", r, string(debug.Stack()))
					}
				}
			}()

			result := calc.Factorial(test.input)

			if result != test.expected {
				t.Errorf("Factorial(%v): expected %v, but got %v", test.input, test.expected, result)
			}

			if result == test.expected {
				t.Logf("SUCCESS: Factorial(%v) == %v", test.input, result)
			}

		})
	}
}
