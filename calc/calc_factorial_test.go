// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Factorial_68fe6fb960
ROOST_METHOD_SIG_HASH=Factorial_3d037eec72

FUNCTION_DEF=func Factorial(n int) int // Factorial (Recursive)

Scenario 1: Factorial of Zero

Details:
  Description: Check if the factorial of 0 returns 1, which is the base case for the factorial function.
Execution:
  Arrange: No setup required.
  Act: Call Factorial(0).
  Assert: Verify that the result is 1.
Validation:
  The choice of assertion is straightforward as the factorial of 0 is well-defined and must return 1. This test ensures that the base case is handled correctly.


*/

// ********RoostGPT********

package calc

import (
	"runtime/debug"
	"testing"
)

func TestFactorial(t *testing.T) {
	type testCase struct {
		name        string
		input       int
		expected    int
		shouldPanic bool
	}

	testCases := []testCase{
		{"Factorial of 0", 0, 1, false},
		{"Factorial of 1", 1, 1, false},
		{"Factorial of 5", 5, 120, false},
		{"Factorial of negative number", -1, 0, true},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if !tc.shouldPanic {
						t.Logf("Panic encountered unexpectedly: %v\n%s", r, string(debug.Stack()))
						t.Fail()
					} else {
						t.Logf("Expected panic occurred: %v", r)
					}
				}
			}()

			result := Factorial(tc.input)
			if result != tc.expected {
				t.Errorf("Factorial(%d) = %d; want %d", tc.input, result, tc.expected)
			} else {
				t.Logf("Factorial(%d) = %d; as expected", tc.input, result)
			}
		})
	}
}
