// ********RoostGPT********
/*
Test generated by RoostGPT for test new-go-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=Factorial_68fe6fb960
ROOST_METHOD_SIG_HASH=Factorial_3d037eec72

FUNCTION_DEF=func Factorial(n int) int // Factorial (Recursive)

Scenario 1: Factorial of a positive number

Details:
    Description: This test is meant to check the Factorial function on a positive integer input, covering the normal operation scenario.
    Execution:
      Arrange: No mocks or test doubles required, provide a positive integer as the test data.
      Act: Invoke the Factorial function with a positive integer.
      Assert: Verify that the actual result matches the manually computed factorial of the input number.
    Validation:
      The choice of assertion is to ensure the Factorial function correctly adheres to the mathematical definition of factorial, and the logic follows from the definition of factorial for positive integers.
      Such a test is of critical importance as it verifies that the function correctly computes factorial under normal operating conditions, thereby being true to its specification and the mathematical definition it is based off of.

Scenario 2: Factorial of zero

Details:
    Description: This test is meant to check the Factorial function on the edge case of zero as input.
    Execution:
      Arrange: No mocks or test doubles required, 0 is the test data.
      Act: Invoke the Factorial function with the input 0.
      Assert: Verify that the actual result matches 1 (since the factorial of 0 is 1).
    Validation:
      The choice of assertion is to ensure that the Factorial function correctly adheres to the mathematical definition of factorial for 0.
      This test is significant because it checks an edge case, ensuring that the function correctly handles and computes the factorial of 0.

Scenario 3: Factorial of a negative number

Details:
    Description: This test is meant to exercise the Factorial function's error handling mechanism when faced with a negative integer input.
    Execution:
      Arrange: No test doubles or mocks required, any negative integer serves as test data.
      Act: Invoke the Factorial function with a negative integer.
      Assert: The test should expect a panic and verify that the panic message is as expected.
    Validation:
      The choice of assertion is to test the function's correctness in handling negative numbers, which is error handling in this case.
      This test is important as it tests the function's resilience and ability to correctly handle inputs outside of its domain.

roost_feedback [22/05/2025, 8:21:07 AM]:add\ssome\scomments\sin\sthe\scode.
*/

// ********RoostGPT********

package calc

import "testing"

// TestFactorial is a test function for testing the Factorial function in the calc package
func TestFactorial(t *testing.T) {

	// defining the test cases
	tests := []struct {
		name         string
		input        int
		expected     int
		expectPanic  bool
		panicMessage string
	}{
		{
			name:     "Factorial of positive number",
			input:    5,
			expected: 120,
		},
		{
			name:     "Factorial of zero",
			input:    0,
			expected: 1,
		},
		{
			name:         "Factorial of negative number",
			input:        -5,
			expectPanic:  true,
			panicMessage: "factorial is not defined for negative numbers",
		},
	}

	// iteration over the test cases
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {

			// defer function to handle panic and check its validity
			defer func() {
				if r := recover(); r != nil {
					if test.expectPanic {
						if r != test.panicMessage {
							t.Fatalf("expected panic message %q but got %q", test.panicMessage, r)
						} else {
							t.Logf("expected panic occurred: %v", r)
						}
					} else {
						t.Fatalf("unexpected panic occurred: %v", r)
					}
				} else if test.expectPanic {
					t.Fatal("expected a panic, but no panic occurred")
				}
			}()

			// call the Factorial function with the input from the test case
			result := Factorial(test.input)

			// check the result of the Factorial function
			if result != test.expected {
				t.Errorf("expected %d but got %d", test.expected, result)
			} else {
				t.Logf("Success: expected %d, received %d", test.expected, result)
			}
		})
	}
}
