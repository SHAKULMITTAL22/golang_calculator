// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model gpt-4o

Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model gpt-4o

Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=Power_1c67a5d8b5
ROOST_METHOD_SIG_HASH=Power_c74b8edd76

FUNCTION_DEF=func Power(base, exponent float64) float64 // Power function

### Test Scenarios for `Power` Function

Below are the test scenarios covering normal operations, edge cases, and special conditions:

---

### Scenario 1: Raise a positive number to a positive integer power

**Details**:  
- **Description**: This test ensures that raising a base to a positive integer exponent (a common operation) is correctly calculated.  
- **Execution**:  
  - **Arrange**: Set `base = 2` and `exponent = 3`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `8` (2³).  
- **Validation**:  
  - Assertion choice: Check if the result matches the expected mathematical value (e.g., 2³ = 8).  
  - Importance: Verifies the correctness of the core functionality with standard positive integer inputs.

---

### Scenario 2: Raise a positive number to a negative integer power  

**Details**:  
- **Description**: This test verifies the handling of negative exponents, which should return the reciprocal of the result for the positive exponent.  
- **Execution**:  
  - **Arrange**: Set `base = 2` and `exponent = -2`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `0.25` (2⁻² = 1/4).  
- **Validation**:  
  - Assertion choice: Confirm that the function correctly computes results for negative exponents.  
  - Importance: Ensures the function correctly handles reciprocal calculations for common mathematical scenarios.

---

### Scenario 3: Raise a positive number to the power of 0  

**Details**:  
- **Description**: Tests the rule that any number raised to the power of 0 should return 1.  
- **Execution**:  
  - **Arrange**: Set `base = 5` and `exponent = 0`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `1`.  
- **Validation**:  
  - Assertion choice: Directly compare the result to `1`.  
  - Importance: Validates compliance with the mathematical rule `x⁰ = 1`, which is crucial for reliability.

---

### Scenario 4: Raise 0 to a positive integer power  

**Details**:  
- **Description**: This test ensures correctness when raising `0` to any positive power, which should always be `0`.  
- **Execution**:  
  - **Arrange**: Set `base = 0` and `exponent = 4`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `0`.  
- **Validation**:  
  - Assertion choice: Check for equality to `0`.  
  - Importance: Ensures compliance with the mathematical rule `0ⁿ = 0` for positive `n`.

---

### Scenario 5: Raise 0 to the power of 0  

**Details**:  
- **Description**: This is a special edge case in mathematics, with some definitions considering `0⁰ = 1`.  
- **Execution**:  
  - **Arrange**: Set `base = 0` and `exponent = 0`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify the behavior (usually `1`, based on `math.Pow` implementation).  
- **Validation**:  
  - Assertion choice: Match the result to `1`, assuming `math.Pow` follows this convention.  
  - Importance: Ensures compatibility with standard implementations and avoids undefined behavior.

---

### Scenario 6: Raise a positive number to a fractional exponent  

**Details**:  
- **Description**: Verifies the correct computation of roots through fractional exponents (e.g., square roots, cube roots).  
- **Execution**:  
  - **Arrange**: Set `base = 9` and `exponent = 0.5`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `3` (since √9 = 3).  
- **Validation**:  
  - Assertion choice: Check numerical closeness (if necessary) due to potential floating-point precision issues.  
  - Importance: Ensures the correct computation of non-integer exponents.

---

### Scenario 7: Raise a negative number to an even integer exponent  

**Details**:  
- **Description**: Ensures that raising a negative number (e.g., -2) to an even power returns a positive result.  
- **Execution**:  
  - **Arrange**: Set `base = -2` and `exponent = 4`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `16`.  
- **Validation**:  
  - Assertion choice: Direct comparison to the correct result.  
  - Importance: Validates mathematical correctness for negative base numbers.

---

### Scenario 8: Raise a negative number to an odd integer exponent  

**Details**:  
- **Description**: Verifies that raising a negative number to an odd exponent produces a negative result.  
- **Execution**:  
  - **Arrange**: Set `base = -3` and `exponent = 3`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `-27`.  
- **Validation**:  
  - Assertion choice: Check for equality with `-27`.  
  - Importance: Ensures correctness for odd-power calculations with negative bases.

---

### Scenario 9: Raise a number to a very large positive exponent  

**Details**:  
- **Description**: Tests the function’s handling of large results and checks for proper precision or overflow handling.  
- **Execution**:  
  - **Arrange**: Set `base = 2` and `exponent = 50`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify the result matches the expected value (`1125899906842624`).  
- **Validation**:  
  - Assertion choice: Check for numerical equivalence, possibly using a precomputed value.  
  - Importance: Ensures reliability under extreme conditions.

---

### Scenario 10: Raise a number to a very large negative exponent  

**Details**:  
- **Description**: Tests precision and performance when computing extremely small fractional results.  
- **Execution**:  
  - **Arrange**: Set `base = 2` and `exponent = -50`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify the result matches the expected small value.  
- **Validation**:  
  - Assertion choice: Confirm the result using numerical closeness, given potential floating-point precision constraints.  
  - Importance: Ensures accurate handling of very small outputs.

---

### Scenario 11: Use fractional base and positive integer exponent  

**Details**:  
- **Description**: Ensures the function calculates powers of fractional numbers correctly.  
- **Execution**:  
  - **Arrange**: Set `base = 0.5` and `exponent = 2`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify that the result is `0.25`.  
- **Validation**:  
  - Assertion choice: Directly compare the result to `0.25`.  
  - Importance: Ensures correct handling of fractional base numbers.

---

### Scenario 12: Test with extremely small fractional base and integer exponent  

**Details**:  
- **Description**: Checks operation with very small base values to confirm precision and lack of underflow issues.  
- **Execution**:  
  - **Arrange**: Set `base = 0.0001` and `exponent = 3`.  
  - **Act**: Call `Power(base, exponent)`.  
  - **Assert**: Verify the result matches the expected value.  
- **Validation**:  
  - Assertion choice: Use numerical closeness for verification due to floating-point precision.  
  - Importance: Ensures proper handling of small inputs without numerical instability.

--- 

By following these scenarios, the `Power` function's correctness and reliability are well-tested under diverse conditions.
*/

// ********RoostGPT********


package calc

import (
	"math"
	"os"
	"runtime/debug"
	"testing"
)







func TestPower(t *testing.T) {

	testCases := []struct {
		name           string
		base           float64
		exponent       float64
		expectedResult float64
	}{

		{"PositiveBasePositiveExponent", 2, 3, 8},

		{"PositiveBaseNegativeExponent", 2, -2, 0.25},

		{"PositiveBaseZeroExponent", 5, 0, 1},

		{"ZeroBasePositiveExponent", 0, 4, 0},

		{"ZeroBaseZeroExponent", 0, 0, 1},

		{"PositiveBaseFractionalExponent", 9, 0.5, 3},

		{"NegativeBaseEvenExponent", -2, 4, 16},

		{"NegativeBaseOddExponent", -3, 3, -27},

		{"LargePositiveExponent", 2, 50, 1125899906842624},

		{"LargeNegativeExponent", 2, -50, math.Pow(2, -50)},

		{"FractionalBasePositiveExponent", 0.5, 2, 0.25},

		{"SmallFractionalBasePositiveExponent", 0.0001, 3, math.Pow(0.0001, 3)},
	}

	for _, testCase := range testCases {
		t.Run(testCase.name, func(t *testing.T) {

			defer func() {
				if r := recover(); r != nil {

					t.Logf("Panic encountered during %s: %v\n%s", testCase.name, r, string(debug.Stack()))
					t.Fail()
				}
			}()

			stdoutBackup := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			result := Power(testCase.base, testCase.exponent)

			w.Close()
			os.Stdout = stdoutBackup

			if math.Abs(result-testCase.expectedResult) > 1e-9 {
				t.Errorf("Test %s failed: expected %f, got %f", testCase.name, testCase.expectedResult, result)
			} else {
				t.Logf("Test %s passed: expected %f, got %f", testCase.name, testCase.expectedResult, result)
			}
		})
	}
}