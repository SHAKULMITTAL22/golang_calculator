// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Absolute_d231f0ab10
ROOST_METHOD_SIG_HASH=Absolute_ec3c06e5a3

FUNCTION_DEF=func Absolute(num float64) float64 // Absolute value

Scenario 1: Positive Number

Details:
  Description: The function should return the absolute value of a positive number.
Execution:
  Arrange: Set up a positive float64 number.
  Act: Invoke the Absolute function with the positive number.
  Assert: Verify that the result is equal to the original number.
Validation:
  The choice of assertion ensures that the function correctly handles positive numbers.
  This test is important to verify that normal operation of the function is correct.

Scenario 2: Negative Number

Details:
  Description: The function should return the absolute value of a negative number.
Execution:
  Arrange: Set up a negative float64 number.
  Act: Invoke the Absolute function with the negative number.
  Assert: Verify that the result is equal to the positive equivalent of the original number.
Validation:
  The choice of assertion ensures that the function correctly handles negative numbers.
  This test is crucial to ensure the function behaves as expected for negative inputs.

Scenario 3: Zero

Details:
  Description: The function should return zero when given zero as input.
Execution:
  Arrange: Set up a float64 number with the value zero.
  Act: Invoke the Absolute function with zero.
  Assert: Verify that the result is zero.
Validation:
  The choice of assertion ensures that the function correctly handles the edge case of zero.
  This test is important to verify that the function does not fail for a zero input.

Scenario 4: Positive Infinity

Details:
  Description: The function should return positive infinity when given positive infinity as input.
Execution:
  Arrange: Set up a float64 number with the value positive infinity.
  Act: Invoke the Absolute function with positive infinity.
  Assert: Verify that the result is positive infinity.
Validation:
  The choice of assertion ensures that the function correctly handles positive infinity.
  This test is important to verify that the function does not fail for special floating-point values.

Scenario 5: Negative Infinity

Details:
  Description: The function should return positive infinity when given negative infinity as input.
Execution:
  Arrange: Set up a float64 number with the value negative infinity.
  Act: Invoke the Absolute function with negative infinity.
  Assert: Verify that the result is positive infinity.
Validation:
  The choice of assertion ensures that the function correctly handles negative infinity.
  This test is important to verify that the function behaves as expected for special floating-point values.

Scenario 6: NaN (Not a Number)

Details:
  Description: The function should return NaN when given NaN as input.
Execution:
  Arrange: Set up a float64 number with the value NaN.
  Act: Invoke the Absolute function with NaN.
  Assert: Verify that the result is NaN.
Validation:
  The choice of assertion ensures that the function correctly handles NaN.
  This test is important to verify that the function does not fail for invalid floating-point values.

*/

// ********RoostGPT********

package calc

import (
	"math"
	"testing"
)

func TestAbsolute(t *testing.T) {
	type test struct {
		name     string
		input    float64
		expected float64
	}

	tests := []test{
		{
			name:     "Positive Number",
			input:    10.5,
			expected: 10.5,
		},
		{
			name:     "Negative Number",
			input:    -10.5,
			expected: 10.5,
		},
		{
			name:     "Zero",
			input:    0,
			expected: 0,
		},
		{
			name:     "Positive Infinity",
			input:    math.Inf(1),
			expected: math.Inf(1),
		},
		{
			name:     "Negative Infinity",
			input:    math.Inf(-1),
			expected: math.Inf(1),
		},
		{
			name:     "NaN",
			input:    math.NaN(),
			expected: math.NaN(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v", r)
					t.Fail()
				}
			}()

			got := Absolute(tt.input)
			if !compareFloat64(got, tt.expected) {
				t.Errorf("Absolute(%f) = %f; want %f", tt.input, got, tt.expected)
			} else {
				t.Logf("Absolute(%f) = %f; as expected", tt.input, got)
			}
		})
	}
}
func compareFloat64(a, b float64) bool {

	if math.IsNaN(a) && math.IsNaN(b) {
		return true
	}
	return a == b
}
