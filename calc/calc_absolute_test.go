// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Absolute_d231f0ab10
ROOST_METHOD_SIG_HASH=Absolute_ec3c06e5a3

FUNCTION_DEF=func Absolute(num float64) float64 // Absolute value

 1: Positive Input

Details:
  Description: The function should return the absolute value of a positive number.
Execution:
  Arrange: Prepare a positive number, e.g., 10.0.
  Act: Call the Absolute function with the positive number as the argument.
  Assert: Verify that the returned value is equal to the input value.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 2: Negative Input

Details:
  Description: The function should return the absolute value of a negative number.
Execution:
  Arrange: Prepare a negative number, e.g., -10.0.
  Act: Call the Absolute function with the negative number as the argument.
  Assert: Verify that the returned value is equal to the positive equivalent of the input value.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 3: Zero Input

Details:
  Description: The function should return 0 when the input is 0.
Execution:
  Arrange: Prepare the number 0.0.
  Act: Call the Absolute function with 0 as the argument.
  Assert: Verify that the returned value is 0.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 4: Maximum Float64 Input

Details:
  Description: The function should handle the maximum float64 value correctly.
Execution:
  Arrange: Prepare the maximum float64 value, math.MaxFloat64.
  Act: Call the Absolute function with math.MaxFloat64 as the argument.
  Assert: Verify that the returned value is equal to math.MaxFloat64.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 5: Minimum Float64 Input

Details:
  Description: The function should handle the minimum float64 value correctly.
Execution:
  Arrange: Prepare the minimum float64 value, -math.MaxFloat64.
  Act: Call the Absolute function with -math.MaxFloat64 as the argument.
  Assert: Verify that the returned value is equal to math.MaxFloat64.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 6: Small Positive Input

Details:
  Description: The function should return the absolute value of a small positive number.
Execution:
  Arrange: Prepare a small positive number, e.g., 0.0001.
  Act: Call the Absolute function with the small positive number as the argument.
  Assert: Verify that the returned value is equal to the input value.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 7: Small Negative Input

Details:
  Description: The function should return the absolute value of a small negative number.
Execution:
  Arrange: Prepare a small negative number, e.g., -0.0001.
  Act: Call the Absolute function with the small negative number as the argument.
  Assert: Verify that the returned value is equal to the positive equivalent of the input value.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 8: Positive Infinity Input

Details:
  Description: The function should handle positive infinity correctly.
Execution:
  Arrange: Prepare positive infinity, e.g., math.Inf(1).
  Act: Call the Absolute function with math.Inf(1) as the argument.
  Assert: Verify that the returned value is equal to math.Inf(1).
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 9: Negative Infinity Input

Details:
  Description: The function should handle negative infinity correctly.
Execution:
  Arrange: Prepare negative infinity, e.g., math.Inf(-1).
  Act: Call the Absolute function with math.Inf(-1) as the argument.
  Assert: Verify that the returned value is equal to math.Inf(1).
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 10: NaN Input

Details:
  Description: The function should handle NaN (Not a Number) correctly.
Execution:
  Arrange: Prepare NaN, e.g., math.NaN().
  Act: Call the Absolute function with math.NaN() as the argument.
  Assert: Verify that the returned value is NaN.
Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

*/

// ********RoostGPT********

package calc

import (
	"math"
	"runtime/debug"
	"testing"
)

func TestAbsolute(t *testing.T) {
	type testCase struct {
		name     string
		input    float64
		expected float64
	}

	tests := []testCase{
		{
			name:     "Positive Input",
			input:    10.0,
			expected: 10.0,
		},
		{
			name:     "Negative Input",
			input:    -10.0,
			expected: 10.0,
		},
		{
			name:     "Zero Input",
			input:    0.0,
			expected: 0.0,
		},
		{
			name:     "Maximum Float64 Input",
			input:    math.MaxFloat64,
			expected: math.MaxFloat64,
		},
		{
			name:     "Minimum Float64 Input",
			input:    -math.MaxFloat64,
			expected: math.MaxFloat64,
		},
		{
			name:     "Small Positive Input",
			input:    0.0001,
			expected: 0.0001,
		},
		{
			name:     "Small Negative Input",
			input:    -0.0001,
			expected: 0.0001,
		},
		{
			name:     "Positive Infinity Input",
			input:    math.Inf(1),
			expected: math.Inf(1),
		},
		{
			name:     "Negative Infinity Input",
			input:    math.Inf(-1),
			expected: math.Inf(1),
		},
		{
			name:     "NaN Input",
			input:    math.NaN(),
			expected: math.NaN(),
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					t.Fail()
				}
			}()

			result := Absolute(tc.input)
			if tc.expected != result {
				t.Errorf("Expected %f but got %f", tc.expected, result)
			}

			t.Logf("Test %s passed.", tc.name)
		})
	}
}
