// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Power_1c67a5d8b5
ROOST_METHOD_SIG_HASH=Power_c74b8edd76

FUNCTION_DEF=func Power(base, exponent float64) float64 // Power function

Sure, here are the test scenarios for the `Power` function in the `calc` package, covering normal operation, edge cases, and error handling:

```
Scenario 1: Positive Base and Exponent

Details:
  Description: This test checks the function's behavior with positive base and exponent values.
Execution:
  Arrange: Set up the test with a positive base and a positive exponent.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result matches the expected value calculated using the math.Pow function.
Validation:
  The choice of assertion is based on the expected output of raising a positive number to a positive power. The test ensures that the function correctly handles standard use cases.

```

```
Scenario 2: Positive Base and Zero Exponent

Details:
  Description: This test verifies the function's behavior when the base is positive and the exponent is zero.
Execution:
  Arrange: Set the base to a positive value and the exponent to zero.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result is 1, as any number raised to the power of zero is 1.
Validation:
  The assertion checks for the correct behavior when the exponent is zero, ensuring the function adheres to mathematical rules.

```

```
Scenario 3: Positive Base and Negative Exponent

Details:
  Description: This test checks the function's behavior with a positive base and a negative exponent.
Execution:
  Arrange: Set the base to a positive value and the exponent to a negative value.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result matches the expected value calculated using the math.Pow function.
Validation:
  This test ensures that the function correctly handles negative exponents, which involves calculating the reciprocal of the base raised to the absolute value of the exponent.

```

```
Scenario 4: Zero Base and Positive Exponent

Details:
  Description: This test verifies the function's behavior when the base is zero and the exponent is positive.
Execution:
  Arrange: Set the base to zero and the exponent to a positive value.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result is 0, as zero raised to any positive power is zero.
Validation:
  The assertion ensures that the function correctly handles the special case where the base is zero and the exponent is positive.

```

```
Scenario 5: Zero Base and Zero Exponent

Details:
  Description: This test checks the function's behavior when both the base and the exponent are zero.
Execution:
  Arrange: Set both the base and the exponent to zero.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result is 1, as zero raised to the power of zero is 1.
Validation:
  This test ensures that the function adheres to the mathematical convention for zero raised to the power of zero.

```

```
Scenario 6: Zero Base and Negative Exponent

Details:
  Description: This test verifies the function's behavior when the base is zero and the exponent is negative.
Execution:
  Arrange: Set the base to zero and the exponent to a negative value.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result is +Inf (positive infinity), as zero raised to a negative power results in a division by zero.
Validation:
  This test ensures that the function handles the division by zero scenario correctly, which is a common mathematical edge case.

```

```
Scenario 7: Negative Base and Even Exponent

Details:
  Description: This test checks the function's behavior with a negative base and an even exponent.
Execution:
  Arrange: Set the base to a negative value and the exponent to an even value.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result is positive, as a negative number raised to an even power results in a positive value.
Validation:
  This test ensures that the function correctly handles the case where the exponent is even, resulting in a positive output.

```

```
Scenario 8: Negative Base and Odd Exponent

Details:
  Description: This test verifies the function's behavior when the base is negative and the exponent is odd.
Execution:
  Arrange: Set the base to a negative value and the exponent to an odd value.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result is negative, as a negative number raised to an odd power remains negative.
Validation:
  This test ensures that the function correctly handles the case where the exponent is odd, resulting in a negative output.

```

```
Scenario 9: Floating-Point Base and Exponent

Details:
  Description: This test checks the function's behavior with floating-point base and exponent values.
Execution:
  Arrange: Set the base and the exponent to floating-point values.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result matches the expected value calculated using the math.Pow function.
Validation:
  This test ensures that the function correctly handles floating-point arithmetic, which is crucial for its intended use case.

```

```
Scenario 10: Large Base and Exponent Values

Details:
  Description: This test verifies the function's behavior with very large base and exponent values.
Execution:
  Arrange: Set the base and the exponent to very large values.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result matches the expected value calculated using the math.Pow function.
Validation:
  This test ensures that the function can handle large numbers without overflow or precision issues.

```

```
Scenario 11: Very Small Base and Exponent Values

Details:
  Description: This test checks the function's behavior with very small base and exponent values.
Execution:
  Arrange: Set the base and the exponent to very small values.
  Act: Invoke the Power function with the arranged parameters.
  Assert: Verify that the result matches the expected value calculated using the math.Pow function.
Validation:
  This test ensures that the function correctly handles very small numbers, which can be prone to precision issues.

```

These scenarios cover a wide range of input conditions, ensuring that the `Power` function in the `calc` package behaves correctly under various circumstances.
*/

// ********RoostGPT********

package calc

import (
	"math"
	"os"
	"runtime/debug"
	"testing"
)

func TestPower(t *testing.T) {

	type testCase struct {
		name     string
		base     float64
		exponent float64
		expected float64
	}

	testCases := []testCase{
		{"Positive Base and Exponent", 2, 3, 8},
		{"Positive Base and Zero Exponent", 2, 0, 1},
		{"Positive Base and Negative Exponent", 2, -3, 0.125},
		{"Zero Base and Positive Exponent", 0, 3, 0},
		{"Zero Base and Zero Exponent", 0, 0, 1},
		{"Zero Base and Negative Exponent", 0, -3, math.NaN()},
		{"Negative Base and Even Exponent", -2, 2, 4},
		{"Negative Base and Odd Exponent", -2, 3, -8},
		{"Floating-Point Base and Exponent", 2.5, 2, 6.25},
		{"Large Base and Exponent Values", 1e10, 2, 1e20},
		{"Very Small Base and Exponent Values", 1e-10, 2, 1e-20},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					t.Fail()
				}
			}()

			oldStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			defer func() {
				w.Close()
				os.Stdout = oldStdout
			}()

			result := Power(tc.base, tc.exponent)

			if result != tc.expected {
				t.Errorf("Expected %v but got %v", tc.expected, result)
			} else {
				t.Logf("Test passed: %s", tc.name)
			}

			r.Close()
		})
	}
}
