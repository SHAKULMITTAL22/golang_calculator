// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Power_1c67a5d8b5
ROOST_METHOD_SIG_HASH=Power_c74b8edd76

FUNCTION_DEF=func Power(base, exponent float64) float64 // Power function

Scenario 1: Basic Positive Exponentiation

  Details:
    Description: This test verifies the basic functionality of the Power function by checking if it correctly computes the power of a positive base raised to a positive exponent.
  Execution:
    Arrange: Prepare a positive base and a positive exponent.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value matches the expected result calculated using a known correct method.
  Validation:
    The choice of assertion checks the correctness of the function's fundamental operation. This is important as it ensures the core functionality of the Power function is working as expected.

Scenario 2: Basic Negative Exponentiation

  Details:
    Description: This test checks the Power function with a positive base and a negative exponent to ensure it correctly handles negative exponents.
  Execution:
    Arrange: Prepare a positive base and a negative exponent.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value matches the expected result, which should be a fraction, calculated using a known correct method.
  Validation:
    This test is crucial as it verifies the function's ability to handle negative exponents, which is a common operation in mathematical computations.

Scenario 3: Base as Zero

  Details:
    Description: This test ensures the Power function correctly handles the case where the base is zero. The result should be zero unless the exponent is zero, in which case the result should be one.
  Execution:
    Arrange: Prepare a base of zero and various exponents, including positive, negative, and zero.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value matches the expected result (zero for non-zero exponents and one for zero exponent).
  Validation:
    This test is important because it verifies the function's behavior when the base is zero, which is a special case in mathematics.

Scenario 4: Exponent as Zero

  Details:
    Description: This test checks the Power function when the exponent is zero to ensure it returns one, regardless of the base value.
  Execution:
    Arrange: Prepare various bases and an exponent of zero.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value is always one.
  Validation:
    This test is crucial as it verifies the function's adherence to the mathematical rule that any number raised to the power of zero is one.

Scenario 5: Base as One

  Details:
    Description: This test ensures the Power function correctly handles the case where the base is one. The result should always be one, regardless of the exponent.
  Execution:
    Arrange: Prepare a base of one and various exponents.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value is always one.
  Validation:
    This test is important because it verifies the function's behavior when the base is one, which is another special case in mathematics.

Scenario 6: Large Exponents

  Details:
    Description: This test checks the Power function with large exponents to ensure it can handle large values without overflow or precision issues.
  Execution:
    Arrange: Prepare a base and a large exponent.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value is correct and within an acceptable range of precision.
  Validation:
    This test is important as it verifies the function's ability to handle large exponents, which is a common requirement in scientific and engineering calculations.

Scenario 7: Large Negative Exponents

  Details:
    Description: This test checks the Power function with large negative exponents to ensure it correctly handles these cases and maintains precision.
  Execution:
    Arrange: Prepare a base and a large negative exponent.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value is correct and within an acceptable range of precision.
  Validation:
    This test is important as it verifies the function's ability to handle large negative exponents, which are less common but still relevant in some mathematical contexts.

Scenario 8: Precision with Floating Point Numbers

  Details:
    Description: This test checks the Power function with floating-point bases and exponents to ensure it handles precision correctly.
  Execution:
    Arrange: Prepare floating-point bases and exponents.
    Act: Invoke the Power function with the prepared base and exponent.
    Assert: Ensure the returned value is correct within an acceptable range of precision.
  Validation:
    This test is important as it verifies the function's ability to handle floating-point arithmetic, which is a common requirement in real-world applications.

*/

// ********RoostGPT********

package calc

import (
	"runtime/debug"
	"testing"
)

func TestPower(t *testing.T) {
	type testCase struct {
		name     string
		base     float64
		exponent float64
		want     float64
	}

	tests := []testCase{
		{name: "Basic Positive Exponentiation", base: 2, exponent: 3, want: 8},
		{name: "Basic Negative Exponentiation", base: 2, exponent: -3, want: 1.0 / 8.0},
		{name: "Base as Zero", base: 0, exponent: 3, want: 0},
		{name: "Base as Zero with Zero Exponent", base: 0, exponent: 0, want: 1},
		{name: "Exponent as Zero", base: 2, exponent: 0, want: 1},
		{name: "Base as One", base: 1, exponent: 3, want: 1},
		{name: "Large Exponents", base: 2, exponent: 10, want: 1024},
		{name: "Large Negative Exponents", base: 2, exponent: -10, want: 1.0 / 1024.0},
		{name: "Precision with Floating Point Numbers", base: 2.5, exponent: 2, want: 6.25},
	}

	for _, tc := range tests {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					t.Fail()
				}
			}()

			got := Power(tc.base, tc.exponent)
			if got != tc.want {
				t.Errorf("Power(%f, %f) = %f; want %f", tc.base, tc.exponent, got, tc.want)
			} else {
				t.Logf("Power(%f, %f) = %f; expected %f", tc.base, tc.exponent, got, tc.want)
			}
		})
	}
}
