// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Power_1c67a5d8b5
ROOST_METHOD_SIG_HASH=Power_c74b8edd76

FUNCTION_DEF=func Power(base, exponent float64) float64 // Power function

Scenario 1: Positive Base and Exponent

Details:
  Description: This test scenario checks the Power function with a positive base and a positive exponent.
Execution:
  Arrange: Set the base to 2.0 and the exponent to 3.0.
  Act: Call Power(2.0, 3.0).
  Assert: Verify the result is 8.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles standard positive inputs correctly.

Scenario 2: Positive Base and Zero Exponent

Details:
  Description: This test scenario checks the Power function with a positive base and a zero exponent.
Execution:
  Arrange: Set the base to 2.0 and the exponent to 0.0.
  Act: Call Power(2.0, 0.0).
  Assert: Verify the result is 1.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function adheres to the mathematical rule that any number raised to the power of zero is 1.

Scenario 3: Positive Base and Negative Exponent

Details:
  Description: This test scenario checks the Power function with a positive base and a negative exponent.
Execution:
  Arrange: Set the base to 2.0 and the exponent to -2.0.
  Act: Call Power(2.0, -2.0).
  Assert: Verify the result is 0.25.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative exponents correctly.

Scenario 4: Zero Base and Positive Exponent

Details:
  Description: This test scenario checks the Power function with a zero base and a positive exponent.
Execution:
  Arrange: Set the base to 0.0 and the exponent to 3.0.
  Act: Call Power(0.0, 3.0).
  Assert: Verify the result is 0.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function adheres to the mathematical rule that zero raised to any positive power is zero.

Scenario 5: Zero Base and Zero Exponent

Details:
  Description: This test scenario checks the Power function with a zero base and a zero exponent.
Execution:
  Arrange: Set the base to 0.0 and the exponent to 0.0.
  Act: Call Power(0.0, 0.0).
  Assert: Verify the result is 1.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles the edge case where both the base and exponent are zero correctly.

Scenario 6: Zero Base and Negative Exponent

Details:
  Description: This test scenario checks the Power function with a zero base and a negative exponent.
Execution:
  Arrange: Set the base to 0.0 and the exponent to -2.0.
  Act: Call Power(0.0, -2.0).
  Assert: Verify the result is infinity.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles the edge case where the base is zero and the exponent is negative correctly.

Scenario 7: Negative Base and Positive Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and a positive exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to 3.0.
  Act: Call Power(-2.0, 3.0).
  Assert: Verify the result is -8.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and positive exponents correctly.

Scenario 8: Negative Base and Even Positive Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and an even positive exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to 2.0.
  Act: Call Power(-2.0, 2.0).
  Assert: Verify the result is 4.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and even positive exponents correctly.

Scenario 9: Negative Base and Odd Positive Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and an odd positive exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to 3.0.
  Act: Call Power(-2.0, 3.0).
  Assert: Verify the result is -8.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and odd positive exponents correctly.

Scenario 10: Negative Base and Zero Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and a zero exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to 0.0.
  Act: Call Power(-2.0, 0.0).
  Assert: Verify the result is 1.0.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and zero exponents correctly.

Scenario 11: Negative Base and Negative Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and a negative exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to -2.0.
  Act: Call Power(-2.0, -2.0).
  Assert: Verify the result is 0.25.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and negative exponents correctly.

Scenario 12: Negative Base and Even Negative Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and an even negative exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to -2.0.
  Act: Call Power(-2.0, -2.0).
  Assert: Verify the result is 0.25.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and even negative exponents correctly.

Scenario 13: Negative Base and Odd Negative Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and an odd negative exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to -3.0.
  Act: Call Power(-2.0, -3.0).
  Assert: Verify the result is -0.125.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles negative bases and odd negative exponents correctly.

Scenario 14: Positive Base and Fractional Exponent

Details:
  Description: This test scenario checks the Power function with a positive base and a fractional exponent.
Execution:
  Arrange: Set the base to 2.0 and the exponent to 0.5.
  Act: Call Power(2.0, 0.5).
  Assert: Verify the result is approximately 1.4142135623730951.
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles fractional exponents correctly.

Scenario 15: Negative Base and Fractional Exponent

Details:
  Description: This test scenario checks the Power function with a negative base and a fractional exponent.
Execution:
  Arrange: Set the base to -2.0 and the exponent to 0.5.
  Act: Call Power(-2.0, 0.5).
  Assert: Verify the result is NaN (Not a Number).
Validation:
  The choice of assertion is to verify the mathematical correctness of the function.
  The test is important to ensure the function handles the edge case where the base is negative and the exponent is fractional correctly.

*/

// ********RoostGPT********


package calc

import (
	"math"
	"os"
	"runtime/debug"
	"testing"
)







func TestPower(t *testing.T) {

	testCases := []struct {
		name     string
		base     float64
		exponent float64
		expected float64
	}{
		{"Positive Base and Exponent", 2.0, 3.0, 8.0},
		{"Positive Base and Zero Exponent", 2.0, 0.0, 1.0},
		{"Positive Base and Negative Exponent", 2.0, -2.0, 0.25},
		{"Zero Base and Positive Exponent", 0.0, 3.0, 0.0},
		{"Zero Base and Zero Exponent", 0.0, 0.0, 1.0},
		{"Zero Base and Negative Exponent", 0.0, -2.0, math.Inf(1)},
		{"Negative Base and Positive Exponent", -2.0, 3.0, -8.0},
		{"Negative Base and Even Positive Exponent", -2.0, 2.0, 4.0},
		{"Negative Base and Odd Positive Exponent", -2.0, 3.0, -8.0},
		{"Negative Base and Zero Exponent", -2.0, 0.0, 1.0},
		{"Negative Base and Negative Exponent", -2.0, -2.0, 0.25},
		{"Negative Base and Even Negative Exponent", -2.0, -2.0, 0.25},
		{"Negative Base and Odd Negative Exponent", -2.0, -3.0, -0.125},
		{"Positive Base and Fractional Exponent", 2.0, 0.5, 1.4142135623730951},
		{"Negative Base and Fractional Exponent", -2.0, 0.5, math.NaN()},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
					t.Fail()
				}
			}()

			old := os.Stdout

			_, w, _ := os.Pipe()
			os.Stdout = w

			result := Power(tc.base, tc.exponent)

			w.Close()
			os.Stdout = old

			if math.IsNaN(result) && math.IsNaN(tc.expected) {
				t.Logf("Result is NaN as expected for base: %f, exponent: %f", tc.base, tc.exponent)
			} else if !math.IsNaN(result) && math.IsNaN(tc.expected) {
				t.Errorf("Expected NaN but got %f for base: %f, exponent: %f", result, tc.base, tc.exponent)
			} else if !math.IsNaN(result) && !math.IsNaN(tc.expected) && math.Abs(result-tc.expected) < 1e-9 {
				t.Logf("Result %f is correct for base: %f, exponent: %f", result, tc.base, tc.exponent)
			} else {
				t.Errorf("Expected %f but got %f for base: %f, exponent: %f", tc.expected, result, tc.base, tc.exponent)
			}
		})
	}
}