// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Power_1c67a5d8b5
ROOST_METHOD_SIG_HASH=Power_c74b8edd76

FUNCTION_DEF=func Power(base, exponent float64) float64 // Power function

Scenario 1: Power of Positive Base and Exponent

Details:
  Description: This test checks the functionality of the Power function with a positive base and a positive exponent. It ensures that the function correctly calculates the power of a positive number raised to a positive exponent.
Execution:
  Arrange: None
  Act: Invoke Power(2.0, 3.0)
  Assert: Verify that the result is 8.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 2: Power of Positive Base and Zero Exponent

Details:
  Description: This test checks the functionality of the Power function with a positive base and a zero exponent. It verifies that any number raised to the power of zero is 1.
Execution:
  Arrange: None
  Act: Invoke Power(5.0, 0.0)
  Assert: Verify that the result is 1.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 3: Power of Positive Base and Negative Exponent

Details:
  Description: This test checks the functionality of the Power function with a positive base and a negative exponent. It ensures that the function correctly handles negative exponents by returning the reciprocal of the power of the positive exponent.
Execution:
  Arrange: None
  Act: Invoke Power(2.0, -3.0)
  Assert: Verify that the result is approximately 0.125

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 4: Power of Zero Base and Positive Exponent

Details:
  Description: This test checks the functionality of the Power function with a zero base and a positive exponent. It verifies that zero raised to any positive power is still zero.
Execution:
  Arrange: None
  Act: Invoke Power(0.0, 5.0)
  Assert: Verify that the result is 0.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 5: Power of Zero Base and Zero Exponent

Details:
  Description: This test checks the functionality of the Power function with a zero base and a zero exponent. It verifies that zero raised to the power of zero is undefined in standard mathematical terms, but in many programming contexts, it is defined as 1.
Execution:
  Arrange: None
  Act: Invoke Power(0.0, 0.0)
  Assert: Verify that the result is 1.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 6: Power of Zero Base and Negative Exponent

Details:
  Description: This test checks the functionality of the Power function with a zero base and a negative exponent. It verifies that zero raised to any negative power results in a division by zero error, which is undefined in standard mathematical terms.
Execution:
  Arrange: None
  Act: Invoke Power(0.0, -3.0)
  Assert: Verify that the result is undefined or handles the division by zero error appropriately.

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 7: Power of Negative Base and Even Positive Exponent

Details:
  Description: This test checks the functionality of the Power function with a negative base and an even positive exponent. It ensures that the function correctly handles negative bases by returning a positive result.
Execution:
  Arrange: None
  Act: Invoke Power(-2.0, 4.0)
  Assert: Verify that the result is 16.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 8: Power of Negative Base and Odd Positive Exponent

Details:
  Description: This test checks the functionality of the Power function with a negative base and an odd positive exponent. It ensures that the function correctly handles negative bases by returning a negative result.
Execution:
  Arrange: None
  Act: Invoke Power(-2.0, 3.0)
  Assert: Verify that the result is -8.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 9: Power of Negative Base and Zero Exponent

Details:
  Description: This test checks the functionality of the Power function with a negative base and a zero exponent. It verifies that any negative number raised to the power of zero is 1.
Execution:
  Arrange: None
  Act: Invoke Power(-3.0, 0.0)
  Assert: Verify that the result is 1.0

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 10: Power of Negative Base and Negative Exponent

Details:
  Description: This test checks the functionality of the Power function with a negative base and a negative exponent. It ensures that the function correctly handles negative exponents by returning the reciprocal of the power of the positive exponent.
Execution:
  Arrange: None
  Act: Invoke Power(-2.0, -3.0)
  Assert: Verify that the result is approximately -0.125

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 11: Power with Large Positive Base and Exponent

Details:
  Description: This test checks the functionality of the Power function with a large positive base and a large positive exponent. It verifies that the function can handle large numbers correctly.
Execution:
  Arrange: None
  Act: Invoke Power(1000.0, 3.0)
  Assert: Verify that the result is 1e+09

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

Scenario 12: Power with Large Negative Base and Exponent

Details:
  Description: This test checks the functionality of the Power function with a large negative base and a large positive exponent. It verifies that the function can handle large negative numbers correctly.
Execution:
  Arrange: None
  Act: Invoke Power(-1000.0, 3.0)
  Assert: Verify that the result is -1e+09

Validation:
  Explain the choice of assertion and the logic behind the expected result.
  Discuss the importance of the test in relation to the application's behavior or business requirements.

*/

// ********RoostGPT********

package calc

import (
	"math"
	"runtime/debug"
	"testing"
)

func TestPower(t *testing.T) {
	type args struct {
		base     float64
		exponent float64
	}
	tests := []struct {
		name  string
		args  args
		want  float64
		panic bool
	}{
		{
			name:  "Power of Positive Base and Exponent",
			args:  args{base: 2.0, exponent: 3.0},
			want:  8.0,
			panic: false,
		},
		{
			name:  "Power of Positive Base and Zero Exponent",
			args:  args{base: 5.0, exponent: 0.0},
			want:  1.0,
			panic: false,
		},
		{
			name:  "Power of Positive Base and Negative Exponent",
			args:  args{base: 2.0, exponent: -3.0},
			want:  0.125,
			panic: false,
		},
		{
			name:  "Power of Zero Base and Positive Exponent",
			args:  args{base: 0.0, exponent: 5.0},
			want:  0.0,
			panic: false,
		},
		{
			name:  "Power of Zero Base and Zero Exponent",
			args:  args{base: 0.0, exponent: 0.0},
			want:  1.0,
			panic: false,
		},
		{
			name:  "Power of Zero Base and Negative Exponent",
			args:  args{base: 0.0, exponent: -3.0},
			want:  math.Inf(1),
			panic: false,
		},
		{
			name:  "Power of Negative Base and Even Positive Exponent",
			args:  args{base: -2.0, exponent: 4.0},
			want:  16.0,
			panic: false,
		},
		{
			name:  "Power of Negative Base and Odd Positive Exponent",
			args:  args{base: -2.0, exponent: 3.0},
			want:  -8.0,
			panic: false,
		},
		{
			name:  "Power of Negative Base and Zero Exponent",
			args:  args{base: -3.0, exponent: 0.0},
			want:  1.0,
			panic: false,
		},
		{
			name:  "Power of Negative Base and Negative Exponent",
			args:  args{base: -2.0, exponent: -3.0},
			want:  -0.125,
			panic: false,
		},
		{
			name:  "Power with Large Positive Base and Exponent",
			args:  args{base: 1000.0, exponent: 3.0},
			want:  1e+09,
			panic: false,
		},
		{
			name:  "Power with Large Negative Base and Exponent",
			args:  args{base: -1000.0, exponent: 3.0},
			want:  -1e+09,
			panic: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if !tt.panic {
						t.Logf("Panic encountered so failing test. %v\n%s", r, string(debug.Stack()))
						t.Fail()
					}
				}
			}()
			if got := Power(tt.args.base, tt.args.exponent); got != tt.want {
				t.Errorf("Power() = %v, want %v", got, tt.want)
			} else {
				t.Logf("Power() = %v, want %v", got, tt.want)
			}
		})
	}
}
