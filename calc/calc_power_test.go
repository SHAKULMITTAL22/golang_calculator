// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model Inference

ROOST_METHOD_HASH=Power_d6b891791f
ROOST_METHOD_SIG_HASH=Power_cc28dcc4c4

FUNCTION_DEF=// Power function
func Power(base, exponent float64) float64 
Scenario 1: Positive Base and Positive Exponent
Details:
  Description: This test checks the function's ability to correctly compute the power when both the base and exponent are positive.
Execution:
  Arrange: None
  Act: Call Power(2, 3)
  Assert: Expect the result to be 8.
Validation:
  The choice of assertion is straightforward since the calculation is simple and well-defined. This test validates the normal operation of the function.

Scenario 2: Positive Base and Zero Exponent
Details:
  Description: This test checks the function's behavior when the base is positive and the exponent is zero.
Execution:
  Arrange: None
  Act: Call Power(5, 0)
  Assert: Expect the result to be 1.
Validation:
  By definition, any number raised to the power of zero is 1. This test ensures that the function handles this edge case correctly.

Scenario 3: Positive Base and Negative Exponent
Details:
  Description: This test checks the function's ability to compute the power when the base is positive and the exponent is negative.
Execution:
  Arrange: None
  Act: Call Power(4, -2)
  Assert: Expect the result to be 0.0625.
Validation:
  This test verifies that the function correctly handles negative exponents by producing the expected fractional result.

Scenario 4: Zero Base and Positive Exponent
Details:
  Description: This test checks the function's behavior when the base is zero and the exponent is positive.
Execution:
  Arrange: None
  Act: Call Power(0, 3)
  Assert: Expect the result to be 0.
Validation:
  By definition, zero raised to any positive power is zero. This test ensures the function adheres to this mathematical rule.

Scenario 5: Zero Base and Zero Exponent
Details:
  Description: This test checks the function's behavior when both the base and the exponent are zero.
Execution:
  Arrange: None
  Act: Call Power(0, 0)
  Assert: Expect the result to be 1.
Validation:
  Mathematically, zero raised to the power of zero is undefined, but many programming environments and mathematical libraries return 1 for this case. This test checks how our function handles this ambiguous scenario.

Scenario 6: Negative Base and Even Positive Exponent
Details:
  Description: This test checks the function's ability to compute the power when the base is negative and the exponent is a positive even number.
Execution:
  Arrange: None
  Act: Call Power(-2, 4)
  Assert: Expect the result to be 16.
Validation:
  This test ensures that the function correctly handles the case where a negative base is raised to an even exponent, resulting in a positive value.

Scenario 7: Negative Base and Odd Positive Exponent
Details:
  Description: This test checks the function's behavior when the base is negative and the exponent is a positive odd number.
Execution:
  Arrange: None
  Act: Call Power(-3, 5)
  Assert: Expect the result to be -243.
Validation:
  This test verifies that the function correctly handles the case where a negative base is raised to an odd exponent, resulting in a negative value.

Scenario 8: Negative Base and Negative Exponent
Details:
  Description: This test checks the function's ability to compute the power when both the base and the exponent are negative.
Execution:
  Arrange: None
  Act: Call Power(-2, -2)
  Assert: Expect the result to be 0.25.
Validation:
  This test ensures that the function correctly handles the case where both the base and the exponent are negative, resulting in a fractional positive value.

Scenario 9: Large Base and Exponent
Details:
  Description: This test checks the function's behavior when both the base and the exponent are large positive numbers.
Execution:
  Arrange: None
  Act: Call Power(10, 5)
  Assert: Expect the result to be 100000.
Validation:
  This test ensures that the function can handle large values without overflow or precision issues, which is crucial for applications requiring high numerical stability.

Scenario 10: Small Base and Large Exponent
Details:
  Description: This test checks the function's behavior when the base is a small positive number and the exponent is a large positive number.
Execution:
  Arrange: None
  Act: Call Power(0.1, 10)
  Assert: Expect the result to be 1e-10.
Validation:
  This test ensures that the function can handle very small results without underflow issues, validating the numerical stability of the function.

*/

// ********RoostGPT********


package calc

import (
	"math"
	"testing"
)







func TestPower(t *testing.T) {

	type testCase struct {
		name       string
		base       float64
		exponent   float64
		expected   float64
		shouldFail bool
	}

	testCases := []testCase{
		{"Positive Base and Positive Exponent", 2, 3, 8, false},
		{"Positive Base and Zero Exponent", 5, 0, 1, false},
		{"Positive Base and Negative Exponent", 4, -2, 0.0625, false},
		{"Zero Base and Positive Exponent", 0, 3, 0, false},
		{"Zero Base and Zero Exponent", 0, 0, 1, false},
		{"Negative Base and Even Positive Exponent", -2, 4, 16, false},
		{"Negative Base and Odd Positive Exponent", -3, 5, -243, false},
		{"Negative Base and Negative Exponent", -2, -2, 0.25, false},
		{"Large Base and Exponent", 10, 5, 100000, false},
		{"Small Base and Large Exponent", 0.1, 10, 1e-10, false},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test. %v", r)
					t.Fail()
				}
			}()

			result := Power(tc.base, tc.exponent)

			if math.Abs(result-tc.expected) > 1e-9 {
				t.Logf("Test failed: %s, expected %f but got %f", tc.name, tc.expected, result)
				t.Fail()
			} else {
				t.Logf("Test passed: %s, expected %f and got %f", tc.name, tc.expected, result)
			}
		})
	}
}