// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Vertex AI and AI Model gemini-2.5-pro-exp-03-25

ROOST_METHOD_HASH=Power_1c67a5d8b5
ROOST_METHOD_SIG_HASH=Power_c74b8edd76

FUNCTION_DEF=func Power(base, exponent float64) float64 // Power function

Okay, here are the Go test scenarios for the `Power` function, following the specified format.

```
Scenario 1: Positive Base, Positive Integer Exponent

Details:
  Description: Test the function with a standard case of a positive base raised to a positive integer exponent. This verifies the basic exponentiation calculation.
Execution:
  Arrange: Set base = 2.0, exponent = 3.0. Expected result = 8.0.
  Act: Call `calc.Power(2.0, 3.0)`.
  Assert: Verify that the returned float64 value is approximately equal to 8.0, using a small tolerance for floating-point comparison (e.g., `math.Abs(result - 8.0) < tolerance`).
Validation:
  Explain the choice of assertion and the logic behind the expected result: Standard mathematical exponentiation dictates 2^3 = 8. Floating-point comparisons require checking for approximate equality due to potential representation inaccuracies.
  Discuss the importance of the test in relation to the application's behavior or business requirements: This is a fundamental test ensuring the core functionality works as expected for common inputs.

Scenario 2: Positive Base, Zero Exponent

Details:
  Description: Test the identity rule where any non-zero number raised to the power of zero equals 1.
Execution:
  Arrange: Set base = 5.5, exponent = 0.0. Expected result = 1.0.
  Act: Call `calc.Power(5.5, 0.0)`.
  Assert: Verify that the returned float64 value is exactly equal to 1.0.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Mathematically, x^0 = 1 for any non-zero x. This specific case often returns an exact 1.0 in floating-point implementations.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates correct handling of the zero exponent edge case, which is a common mathematical rule.

Scenario 3: Base One, Any Exponent

Details:
  Description: Test the identity rule where 1 raised to any power equals 1.
Execution:
  Arrange: Set base = 1.0, exponent = 123.45 (or any other value, including 0, negative, NaN). Expected result = 1.0.
  Act: Call `calc.Power(1.0, 123.45)`.
  Assert: Verify that the returned float64 value is exactly equal to 1.0.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Mathematically, 1^y = 1 for any y. This is a specific behavior defined in `math.Pow`.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the function correctly handles the specific edge case of base 1.

Scenario 4: Zero Base, Positive Exponent

Details:
  Description: Test the case where the base is zero and the exponent is positive. The result should be zero.
Execution:
  Arrange: Set base = 0.0, exponent = 4.0. Expected result = 0.0.
  Act: Call `calc.Power(0.0, 4.0)`.
  Assert: Verify that the returned float64 value is exactly equal to 0.0.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Mathematically, 0^y = 0 for any y > 0.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Covers a specific scenario involving zero as the base.

Scenario 5: Positive Base, Negative Integer Exponent

Details:
  Description: Test the function with a negative integer exponent, which should result in the reciprocal of the base raised to the positive exponent.
Execution:
  Arrange: Set base = 4.0, exponent = -2.0. Expected result = 1 / (4^2) = 1/16 = 0.0625.
  Act: Call `calc.Power(4.0, -2.0)`.
  Assert: Verify that the returned float64 value is approximately equal to 0.0625, using a small tolerance.
Validation:
  Explain the choice of assertion and the logic behind the expected result: x^-y = 1 / (x^y). Floating-point comparison requires tolerance.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures correct calculation for negative exponents, representing division or reciprocals.

Scenario 6: Negative Base, Positive Odd Integer Exponent

Details:
  Description: Test the function with a negative base raised to a positive odd integer exponent. The result should be negative.
Execution:
  Arrange: Set base = -2.0, exponent = 3.0. Expected result = -8.0.
  Act: Call `calc.Power(-2.0, 3.0)`.
  Assert: Verify that the returned float64 value is approximately equal to -8.0, using a small tolerance.
Validation:
  Explain the choice of assertion and the logic behind the expected result: A negative base raised to an odd integer power results in a negative number. (-2)^3 = -8. Tolerance is used for float comparison.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates correct sign handling for negative bases with odd exponents.

Scenario 7: Negative Base, Positive Even Integer Exponent

Details:
  Description: Test the function with a negative base raised to a positive even integer exponent. The result should be positive.
Execution:
  Arrange: Set base = -2.0, exponent = 4.0. Expected result = 16.0.
  Act: Call `calc.Power(-2.0, 4.0)`.
  Assert: Verify that the returned float64 value is approximately equal to 16.0, using a small tolerance.
Validation:
  Explain the choice of assertion and the logic behind the expected result: A negative base raised to an even integer power results in a positive number. (-2)^4 = 16. Tolerance is used for float comparison.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates correct sign handling for negative bases with even exponents.

Scenario 8: Positive Base, Fractional Exponent (Root)

Details:
  Description: Test the function with a fractional exponent, representing a root calculation (e.g., square root).
Execution:
  Arrange: Set base = 9.0, exponent = 0.5. Expected result = 3.0.
  Act: Call `calc.Power(9.0, 0.5)`.
  Assert: Verify that the returned float64 value is approximately equal to 3.0, using a small tolerance.
Validation:
  Explain the choice of assertion and the logic behind the expected result: x^(1/n) is the nth root of x. 9^0.5 is the square root of 9, which is 3. Tolerance is used for float comparison.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the function handles non-integer exponents correctly, enabling root calculations.

Scenario 9: Zero Base, Zero Exponent (Special Case)

Details:
  Description: Test the mathematically ambiguous case of 0^0. Go's `math.Pow(0, 0)` defines this as 1.
Execution:
  Arrange: Set base = 0.0, exponent = 0.0. Expected result = 1.0.
  Act: Call `calc.Power(0.0, 0.0)`.
  Assert: Verify that the returned float64 value is exactly equal to 1.0.
Validation:
  Explain the choice of assertion and the logic behind the expected result: While mathematically debated, `math.Pow(0, 0)` returns 1 by definition in Go's standard library.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Verifies adherence to the specific behavior defined by the underlying `math.Pow` function for this edge case.

Scenario 10: Zero Base, Negative Exponent (Infinity)

Details:
  Description: Test raising zero to a negative power, which should result in positive infinity due to division by zero.
Execution:
  Arrange: Set base = 0.0, exponent = -2.0. Expected result = Positive Infinity.
  Act: Call `calc.Power(0.0, -2.0)`.
  Assert: Verify that the returned float64 value is positive infinity using `math.IsInf(result, 1)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: 0^-y = 1 / (0^y) = 1/0, which results in positive infinity in floating-point arithmetic. `math.IsInf` with sign argument 1 checks for +Inf.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures correct handling of division-by-zero scenarios leading to infinite results, as defined by IEEE 754.

Scenario 11: Negative Base, Non-Integer Exponent (NaN)

Details:
  Description: Test raising a negative base to a non-integer exponent (e.g., square root of -1). This is undefined in real numbers and should result in NaN (Not a Number).
Execution:
  Arrange: Set base = -4.0, exponent = 0.5. Expected result = NaN.
  Act: Call `calc.Power(-4.0, 0.5)`.
  Assert: Verify that the returned float64 value is NaN using `math.IsNaN(result)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: The result of raising a negative number to a non-integer power is not a real number. IEEE 754 defines NaN for such results. `math.IsNaN` is the standard way to check for NaN.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Verifies correct handling of mathematically undefined operations within the domain of real numbers, returning NaN as expected.

Scenario 12: Base is NaN

Details:
  Description: Test the function's behavior when the base input is NaN. The result should propagate NaN (except for Pow(NaN, 0)).
Execution:
  Arrange: Set base = `math.NaN()`, exponent = 2.0. Expected result = NaN.
  Act: Call `calc.Power(math.NaN(), 2.0)`.
  Assert: Verify that the returned float64 value is NaN using `math.IsNaN(result)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Operations involving NaN typically result in NaN. `math.IsNaN` checks for this special value.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures correct propagation of invalid numeric states (NaN) through calculations.

Scenario 13: Exponent is NaN

Details:
  Description: Test the function's behavior when the exponent input is NaN. The result should propagate NaN (except for Pow(1, NaN)).
Execution:
  Arrange: Set base = 2.0, exponent = `math.NaN()`. Expected result = NaN.
  Act: Call `calc.Power(2.0, math.NaN())`.
  Assert: Verify that the returned float64 value is NaN using `math.IsNaN(result)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Operations involving NaN typically result in NaN. `math.IsNaN` checks for this special value.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures correct propagation of invalid numeric states (NaN) through calculations.

Scenario 14: Base is Positive Infinity, Positive Exponent

Details:
  Description: Test raising positive infinity to a positive power. The result should be positive infinity.
Execution:
  Arrange: Set base = `math.Inf(1)`, exponent = 2.0. Expected result = Positive Infinity.
  Act: Call `calc.Power(math.Inf(1), 2.0)`.
  Assert: Verify that the returned float64 value is positive infinity using `math.IsInf(result, 1)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Infinity raised to a positive power remains infinity. `math.IsInf` checks for infinite values.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates handling of infinite inputs according to floating-point standards.

Scenario 15: Base is Positive Infinity, Negative Exponent

Details:
  Description: Test raising positive infinity to a negative power. The result should be positive zero.
Execution:
  Arrange: Set base = `math.Inf(1)`, exponent = -2.0. Expected result = +0.0.
  Act: Call `calc.Power(math.Inf(1), -2.0)`.
  Assert: Verify that the returned float64 value is 0.0 and specifically positive zero (check `result == 0.0 && !math.Signbit(result)`).
Validation:
  Explain the choice of assertion and the logic behind the expected result: (+Inf)^-y = 1 / ((+Inf)^y) = 1 / +Inf = +0. Checking the sign bit distinguishes +0 from -0.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates handling of infinite inputs leading to zero, respecting the sign of zero per IEEE 754.

Scenario 16: Base is Negative Infinity, Positive Odd Integer Exponent

Details:
  Description: Test raising negative infinity to a positive odd integer power. The result should be negative infinity.
Execution:
  Arrange: Set base = `math.Inf(-1)`, exponent = 3.0. Expected result = Negative Infinity.
  Act: Call `calc.Power(math.Inf(-1), 3.0)`.
  Assert: Verify that the returned float64 value is negative infinity using `math.IsInf(result, -1)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: (-Inf)^odd = -Inf. `math.IsInf` with sign argument -1 checks for -Inf.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates handling of negative infinite inputs according to floating-point standards and sign rules.

Scenario 17: Base is Negative Infinity, Positive Even Integer Exponent

Details:
  Description: Test raising negative infinity to a positive even integer power. The result should be positive infinity.
Execution:
  Arrange: Set base = `math.Inf(-1)`, exponent = 2.0. Expected result = Positive Infinity.
  Act: Call `calc.Power(math.Inf(-1), 2.0)`.
  Assert: Verify that the returned float64 value is positive infinity using `math.IsInf(result, 1)`.
Validation:
  Explain the choice of assertion and the logic behind the expected result: (-Inf)^even = +Inf. `math.IsInf` with sign argument 1 checks for +Inf.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Validates handling of negative infinite inputs according to floating-point standards and sign rules.
```
*/

// ********RoostGPT********

package calc

import (
	"math"
	"runtime/debug"
	"testing"
)

func TestPower(t *testing.T) {

	const tolerance = 1e-9

	testCases := []struct {
		name         string
		base         float64
		exponent     float64
		expected     float64
		checkType    string
		description  string
		validation   string
		businessNeed string
	}{

		{
			name:         "Scenario 1: Positive Base, Positive Integer Exponent",
			base:         2.0,
			exponent:     3.0,
			expected:     8.0,
			checkType:    "approx",
			description:  "Test the function with a standard case of a positive base raised to a positive integer exponent.",
			validation:   "Standard mathematical exponentiation dictates 2^3 = 8. Floating-point comparisons require checking for approximate equality due to potential representation inaccuracies.",
			businessNeed: "This is a fundamental test ensuring the core functionality works as expected for common inputs.",
		},

		{
			name:         "Scenario 2: Positive Base, Zero Exponent",
			base:         5.5,
			exponent:     0.0,
			expected:     1.0,
			checkType:    "exact",
			description:  "Test the identity rule where any non-zero number raised to the power of zero equals 1.",
			validation:   "Mathematically, x^0 = 1 for any non-zero x. This specific case often returns an exact 1.0 in floating-point implementations.",
			businessNeed: "Validates correct handling of the zero exponent edge case, which is a common mathematical rule.",
		},

		{
			name:         "Scenario 3: Base One, Any Exponent",
			base:         1.0,
			exponent:     123.45,
			expected:     1.0,
			checkType:    "exact",
			description:  "Test the identity rule where 1 raised to any power equals 1.",
			validation:   "Mathematically, 1^y = 1 for any y. This is a specific behavior defined in \"math.Pow\".",
			businessNeed: "Ensures the function correctly handles the specific edge case of base 1.",
		},

		{
			name:         "Scenario 4: Zero Base, Positive Exponent",
			base:         0.0,
			exponent:     4.0,
			expected:     0.0,
			checkType:    "exact",
			description:  "Test the case where the base is zero and the exponent is positive. The result should be zero.",
			validation:   "Mathematically, 0^y = 0 for any y > 0.",
			businessNeed: "Covers a specific scenario involving zero as the base.",
		},

		{
			name:         "Scenario 5: Positive Base, Negative Integer Exponent",
			base:         4.0,
			exponent:     -2.0,
			expected:     0.0625,
			checkType:    "approx",
			description:  "Test the function with a negative integer exponent, which should result in the reciprocal of the base raised to the positive exponent.",
			validation:   "x^-y = 1 / (x^y). Floating-point comparison requires tolerance.",
			businessNeed: "Ensures correct calculation for negative exponents, representing division or reciprocals.",
		},

		{
			name:         "Scenario 6: Negative Base, Positive Odd Integer Exponent",
			base:         -2.0,
			exponent:     3.0,
			expected:     -8.0,
			checkType:    "approx",
			description:  "Test the function with a negative base raised to a positive odd integer exponent. The result should be negative.",
			validation:   "A negative base raised to an odd integer power results in a negative number. (-2)^3 = -8. Tolerance is used for float comparison.",
			businessNeed: "Validates correct sign handling for negative bases with odd exponents.",
		},

		{
			name:         "Scenario 7: Negative Base, Positive Even Integer Exponent",
			base:         -2.0,
			exponent:     4.0,
			expected:     16.0,
			checkType:    "approx",
			description:  "Test the function with a negative base raised to a positive even integer exponent. The result should be positive.",
			validation:   "A negative base raised to an even integer power results in a positive number. (-2)^4 = 16. Tolerance is used for float comparison.",
			businessNeed: "Validates correct sign handling for negative bases with even exponents.",
		},

		{
			name:         "Scenario 8: Positive Base, Fractional Exponent (Root)",
			base:         9.0,
			exponent:     0.5,
			expected:     3.0,
			checkType:    "approx",
			description:  "Test the function with a fractional exponent, representing a root calculation (e.g., square root).",
			validation:   "x^(1/n) is the nth root of x. 9^0.5 is the square root of 9, which is 3. Tolerance is used for float comparison.",
			businessNeed: "Ensures the function handles non-integer exponents correctly, enabling root calculations.",
		},

		{
			name:         "Scenario 9: Zero Base, Zero Exponent (Special Case)",
			base:         0.0,
			exponent:     0.0,
			expected:     1.0,
			checkType:    "exact",
			description:  "Test the mathematically ambiguous case of 0^0. Go's \"math.Pow(0, 0)\" defines this as 1.",
			validation:   "While mathematically debated, \"math.Pow(0, 0)\" returns 1 by definition in Go's standard library.",
			businessNeed: "Verifies adherence to the specific behavior defined by the underlying \"math.Pow\" function for this edge case.",
		},

		{
			name:         "Scenario 10: Zero Base, Negative Exponent (Infinity)",
			base:         0.0,
			exponent:     -2.0,
			expected:     math.Inf(1),
			checkType:    "posinf",
			description:  "Test raising zero to a negative power, which should result in positive infinity due to division by zero.",
			validation:   "0^-y = 1 / (0^y) = 1/0, which results in positive infinity in floating-point arithmetic. \"math.IsInf\" with sign argument 1 checks for +Inf.",
			businessNeed: "Ensures correct handling of division-by-zero scenarios leading to infinite results, as defined by IEEE 754.",
		},

		{
			name:         "Scenario 11: Negative Base, Non-Integer Exponent (NaN)",
			base:         -4.0,
			exponent:     0.5,
			expected:     math.NaN(),
			checkType:    "nan",
			description:  "Test raising a negative base to a non-integer exponent (e.g., square root of -1). This is undefined in real numbers and should result in NaN (Not a Number).",
			validation:   "The result of raising a negative number to a non-integer power is not a real number. IEEE 754 defines NaN for such results. \"math.IsNaN\" is the standard way to check for NaN.",
			businessNeed: "Verifies correct handling of mathematically undefined operations within the domain of real numbers, returning NaN as expected.",
		},

		{
			name:         "Scenario 12: Base is NaN",
			base:         math.NaN(),
			exponent:     2.0,
			expected:     math.NaN(),
			checkType:    "nan",
			description:  "Test the function's behavior when the base input is NaN. The result should propagate NaN (except for Pow(NaN, 0)).",
			validation:   "Operations involving NaN typically result in NaN. \"math.IsNaN\" checks for this special value.",
			businessNeed: "Ensures correct propagation of invalid numeric states (NaN) through calculations.",
		},

		{
			name:         "Scenario 13: Exponent is NaN",
			base:         2.0,
			exponent:     math.NaN(),
			expected:     math.NaN(),
			checkType:    "nan",
			description:  "Test the function's behavior when the exponent input is NaN. The result should propagate NaN (except for Pow(1, NaN)).",
			validation:   "Operations involving NaN typically result in NaN. \"math.IsNaN\" checks for this special value.",
			businessNeed: "Ensures correct propagation of invalid numeric states (NaN) through calculations.",
		},

		{
			name:         "Scenario 14: Base is Positive Infinity, Positive Exponent",
			base:         math.Inf(1),
			exponent:     2.0,
			expected:     math.Inf(1),
			checkType:    "posinf",
			description:  "Test raising positive infinity to a positive power. The result should be positive infinity.",
			validation:   "Infinity raised to a positive power remains infinity. \"math.IsInf\" checks for infinite values.",
			businessNeed: "Validates handling of infinite inputs according to floating-point standards.",
		},

		{
			name:         "Scenario 15: Base is Positive Infinity, Negative Exponent",
			base:         math.Inf(1),
			exponent:     -2.0,
			expected:     0.0,
			checkType:    "poszero",
			description:  "Test raising positive infinity to a negative power. The result should be positive zero.",
			validation:   "(+Inf)^-y = 1 / ((+Inf)^y) = 1 / +Inf = +0. Checking the sign bit distinguishes +0 from -0.",
			businessNeed: "Validates handling of infinite inputs leading to zero, respecting the sign of zero per IEEE 754.",
		},

		{
			name:         "Scenario 16: Base is Negative Infinity, Positive Odd Integer Exponent",
			base:         math.Inf(-1),
			exponent:     3.0,
			expected:     math.Inf(-1),
			checkType:    "neginf",
			description:  "Test raising negative infinity to a positive odd integer power. The result should be negative infinity.",
			validation:   "(-Inf)^odd = -Inf. \"math.IsInf\" with sign argument -1 checks for -Inf.",
			businessNeed: "Validates handling of negative infinite inputs according to floating-point standards and sign rules.",
		},

		{
			name:         "Scenario 17: Base is Negative Infinity, Positive Even Integer Exponent",
			base:         math.Inf(-1),
			exponent:     2.0,
			expected:     math.Inf(1),
			checkType:    "posinf",
			description:  "Test raising negative infinity to a positive even integer power. The result should be positive infinity.",
			validation:   "(-Inf)^even = +Inf. \"math.IsInf\" with sign argument 1 checks for +Inf.",
			businessNeed: "Validates handling of negative infinite inputs according to floating-point standards and sign rules.",
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {

			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered in test case '%s': %v\n%s", tc.name, r, string(debug.Stack()))
					t.Errorf("Test panicked unexpectedly")
				}
			}()

			t.Logf("Running Test Case: %s", tc.name)
			t.Logf("Description: %s", tc.description)
			t.Logf("Arrange: base = %v, exponent = %v", tc.base, tc.exponent)
			t.Logf("Expected Check Type: %s, Expected Value (if applicable): %v", tc.checkType, tc.expected)
			t.Logf("Validation Logic: %s", tc.validation)
			t.Logf("Business Need: %s", tc.businessNeed)

			result := Power(tc.base, tc.exponent)
			t.Logf("Act: Called Power(%v, %v). Result: %v", tc.base, tc.exponent, result)

			var success bool
			var failureMsg string

			switch tc.checkType {
			case "approx":
				diff := math.Abs(result - tc.expected)
				success = diff < tolerance
				if !success {
					failureMsg = "Result differs from expected value by more than the tolerance."
				}
			case "exact":
				success = result == tc.expected
				if !success {
					failureMsg = "Result does not exactly match the expected value."
				}
			case "nan":
				success = math.IsNaN(result)
				if !success {
					failureMsg = "Result was expected to be NaN, but it was not."
				}
			case "posinf":
				success = math.IsInf(result, 1)
				if !success {
					failureMsg = "Result was expected to be Positive Infinity, but it was not."
				}
			case "neginf":
				success = math.IsInf(result, -1)
				if !success {
					failureMsg = "Result was expected to be Negative Infinity, but it was not."
				}
			case "poszero":

				success = result == 0.0 && !math.Signbit(result)
				if !success {
					failureMsg = "Result was expected to be Positive Zero (+0.0), but it was not."
				}
			default:
				t.Fatalf("Unknown checkType '%s' in test case '%s'", tc.checkType, tc.name)
			}

			if success {
				t.Logf("Assert: PASSED. Result %v matched expectation for check type '%s'.", result, tc.checkType)
			} else {
				t.Errorf("Assert: FAILED. %s Expected (approx/exact): %v, Got: %v", failureMsg, tc.expected, result)
			}
		})
	}
}
